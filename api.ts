/**
 * LaunchDarkly REST API
 * Build custom integrations with the LaunchDarkly REST API
 *
 * OpenAPI spec version: 2.0.9
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://app.launchdarkly.com/api/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* An action to perform on a resource.
*/
export class Action {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Action.attributeTypeMap;
    }
}

export class Actions extends Array<Action> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Actions.attributeTypeMap);
    }
}

export class AuditLogEntries {
    'links': Links;
    'items': Array<AuditLogEntry>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AuditLogEntry>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntries.attributeTypeMap;
    }
}

export class AuditLogEntry {
    'links': Links;
    'id': Id;
    'date': number;
    'kind': string;
    'name': string;
    'description': string;
    'shortDescription': string;
    'comment': string;
    'member': Member;
    'titleVerb': string;
    'title': string;
    'target': AuditLogEntryTarget;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "Member"
        },
        {
            "name": "titleVerb",
            "baseName": "titleVerb",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "AuditLogEntryTarget"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntry.attributeTypeMap;
    }
}

export class AuditLogEntryTarget {
    'links': Links;
    'name': string;
    'resources': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntryTarget.attributeTypeMap;
    }
}

export class Clause {
    'attribute': string;
    'op': string;
    'values': Array<any>;
    'negate': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attribute",
            "baseName": "attribute",
            "type": "string"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<any>"
        },
        {
            "name": "negate",
            "baseName": "negate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Clause.attributeTypeMap;
    }
}

/**
* A mapping of keys to CustomProperty entries.
*/
export class CustomProperties {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomProperties.attributeTypeMap;
    }
}

/**
* A name and value describing a custom property.
*/
export class CustomProperty {
    /**
    * The name of the property.
    */
    'name': string;
    'value': CustomPropertyValues;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "CustomPropertyValues"
        }    ];

    static getAttributeTypeMap() {
        return CustomProperty.attributeTypeMap;
    }
}

/**
* Values for this property.
*/
export class CustomPropertyValues extends Array<string> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CustomPropertyValues.attributeTypeMap);
    }
}

export class CustomRole {
    'links': Links;
    /**
    * Name of the custom role.
    */
    'name': string;
    'key': CustomRoleKeyOrId;
    /**
    * Description of the custom role.
    */
    'description': string;
    'id': Id;
    'policy': Array<Policy>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "CustomRoleKeyOrId"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRole.attributeTypeMap;
    }
}

export class CustomRoleBody {
    /**
    * Name of the custom role.
    */
    'name': string;
    /**
    * Description of the custom role.
    */
    'description': string;
    'key': CustomRoleKeyOrId;
    'policy': Array<Policy>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "CustomRoleKeyOrId"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoleBody.attributeTypeMap;
    }
}

/**
* The 20-hexdigit id or the key for a custom role.
*/
export class CustomRoleKeyOrId {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomRoleKeyOrId.attributeTypeMap;
    }
}

export class CustomRoles {
    'links': Links;
    'items': CustomRole;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "CustomRole"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoles.attributeTypeMap;
    }
}

export class Environment {
    'links': Links;
    'id': Id;
    /**
    * The key for the environment.
    */
    'key': string;
    /**
    * The name of the environment.
    */
    'name': string;
    /**
    * The SDK key for backend LaunchDarkly SDKs.
    */
    'apiKey': string;
    /**
    * The SDK key for mobile LaunchDarkly SDKs.
    */
    'mobileKey': string;
    /**
    * The swatch color for the environment.
    */
    'color': string;
    /**
    * The default TTL.
    */
    'defaultTtl': number;
    /**
    * Determines if this environment is in safe mode.
    */
    'secureMode': boolean;
    /**
    * Set to true to send detailed event information for new flags.
    */
    'defaultTrackEvents': boolean;
    /**
    * An array of tags for this environment.
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "mobileKey",
            "baseName": "mobileKey",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        },
        {
            "name": "secureMode",
            "baseName": "secureMode",
            "type": "boolean"
        },
        {
            "name": "defaultTrackEvents",
            "baseName": "defaultTrackEvents",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Environment.attributeTypeMap;
    }
}

export class EnvironmentBody {
    /**
    * The name of the new environment.
    */
    'name': string;
    /**
    * A project-unique key for the new environment.
    */
    'key': string;
    /**
    * A color swatch (as an RGB hex value with no leading '#', e.g. C8C8C8).
    */
    'color': string;
    /**
    * The default TTL for the new environment.
    */
    'defaultTtl': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EnvironmentBody.attributeTypeMap;
    }
}

export class Fallthrough {
    'variation': number;
    'rollout': Rollout;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        }    ];

    static getAttributeTypeMap() {
        return Fallthrough.attributeTypeMap;
    }
}

export class FeatureFlag {
    'key': string;
    /**
    * Name of the feature flag.
    */
    'name': string;
    /**
    * Description of the feature flag.
    */
    'description': string;
    /**
    * Whether the feature flag is a boolean flag or multivariate.
    */
    'kind': string;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate': number;
    'includeInSnippet': boolean;
    /**
    * Whether or not this flag is temporary.
    */
    'temporary': boolean;
    /**
    * The ID of the member that should maintain this flag.
    */
    'maintainerId': string;
    /**
    * An array of tags for this feature flag.
    */
    'tags': Array<string>;
    /**
    * The variations for this feature flag.
    */
    'variations': Array<Variation>;
    'customProperties': CustomProperties;
    'links': Links;
    'maintainer': Member;
    'environments': { [key: string]: FeatureFlagConfig; };

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "maintainerId",
            "baseName": "maintainerId",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "customProperties",
            "baseName": "customProperties",
            "type": "CustomProperties"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "maintainer",
            "baseName": "_maintainer",
            "type": "Member"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "{ [key: string]: FeatureFlagConfig; }"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlag.attributeTypeMap;
    }
}

export class FeatureFlagBody {
    /**
    * A human-friendly name for the feature flag. Remember to note if this flag is intended to be temporary or permanent.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the flag in your code.
    */
    'key': string;
    /**
    * A description of the feature flag.
    */
    'description': string;
    /**
    * An array of possible variations for the flag.
    */
    'variations': Array<Variation>;
    /**
    * Whether or not the flag is a temporary flag.
    */
    'temporary': boolean;
    /**
    * Tags for the feature flag.
    */
    'tags': Array<string>;
    /**
    * Whether or not this flag should be made available to the client-side JavaScript SDK.
    */
    'includeInSnippet': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagBody.attributeTypeMap;
    }
}

export class FeatureFlagConfig {
    'on': boolean;
    'archived': boolean;
    'salt': string;
    'sel': string;
    'lastModified': number;
    'version': number;
    'targets': Array<Target>;
    'goalIds': Array<string>;
    'rules': Array<Rule>;
    'fallthrough': Fallthrough;
    'offVariation': number;
    'prerequisites': Array<Prerequisite>;
    /**
    * Set to true to send detailed event information for this flag.
    */
    'trackEvents': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "salt",
            "baseName": "salt",
            "type": "string"
        },
        {
            "name": "sel",
            "baseName": "sel",
            "type": "string"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "targets",
            "baseName": "targets",
            "type": "Array<Target>"
        },
        {
            "name": "goalIds",
            "baseName": "goalIds",
            "type": "Array<string>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<Rule>"
        },
        {
            "name": "fallthrough",
            "baseName": "fallthrough",
            "type": "Fallthrough"
        },
        {
            "name": "offVariation",
            "baseName": "offVariation",
            "type": "number"
        },
        {
            "name": "prerequisites",
            "baseName": "prerequisites",
            "type": "Array<Prerequisite>"
        },
        {
            "name": "trackEvents",
            "baseName": "trackEvents",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagConfig.attributeTypeMap;
    }
}

export class FeatureFlagStatus {
    'links': Links;
    /**
    * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn't been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
    */
    'name': FeatureFlagStatus.NameEnum;
    'lastRequested': string;
    '_default': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "FeatureFlagStatus.NameEnum"
        },
        {
            "name": "lastRequested",
            "baseName": "lastRequested",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatus.attributeTypeMap;
    }
}

export namespace FeatureFlagStatus {
    export enum NameEnum {
        New = <any> 'new',
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Launched = <any> 'launched'
    }
}
export class FeatureFlagStatuses {
    'links': Links;
    'items': Array<FeatureFlagStatus>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlagStatus>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatuses.attributeTypeMap;
    }
}

export class FeatureFlags {
    'links': Links;
    'items': Array<FeatureFlag>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlag>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlags.attributeTypeMap;
    }
}

/**
* The unique resource id.
*/
export class Id {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Id.attributeTypeMap;
    }
}

export class Link {
    'href': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

export class Links {
    'self': Link;
    'next': Link;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class Member {
    'links': Links;
    'id': Id;
    'role': Role;
    'email': string;
    'pendingInvite': boolean;
    'isBeta': boolean;
    'customRoles': Array<Id>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "pendingInvite",
            "baseName": "_pendingInvite",
            "type": "boolean"
        },
        {
            "name": "isBeta",
            "baseName": "isBeta",
            "type": "boolean"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<Id>"
        }    ];

    static getAttributeTypeMap() {
        return Member.attributeTypeMap;
    }
}

export class Members {
    'links': Links;
    'items': Member;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Member"
        }    ];

    static getAttributeTypeMap() {
        return Members.attributeTypeMap;
    }
}

export class MembersBody {
    'email': string;
    'firstName': string;
    'lastName': string;
    'role': Role;
    'customRoles': Array<CustomRoleKeyOrId>;
    'inlineRole': Statements;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<CustomRoleKeyOrId>"
        },
        {
            "name": "inlineRole",
            "baseName": "inlineRole",
            "type": "Statements"
        }    ];

    static getAttributeTypeMap() {
        return MembersBody.attributeTypeMap;
    }
}

export class PatchComment {
    'comment': string;
    'patch': Array<PatchOperation>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "Array<PatchOperation>"
        }    ];

    static getAttributeTypeMap() {
        return PatchComment.attributeTypeMap;
    }
}

export class PatchOperation {
    'op': string;
    'path': string;
    'value': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return PatchOperation.attributeTypeMap;
    }
}

export class Policy {
    'resources': Resources;
    'actions': Actions;
    /**
    * Effect of the policy - allow or deny.
    */
    'effect': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Resources"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Actions"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Policy.attributeTypeMap;
    }
}

export class Prerequisite {
    'key': string;
    'variation': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Prerequisite.attributeTypeMap;
    }
}

export class Project {
    'links': Links;
    'id': Id;
    'key': string;
    'name': string;
    'environments': Array<Environment>;
    /**
    * An array of tags for this project.
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "Array<Environment>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Project.attributeTypeMap;
    }
}

export class ProjectBody {
    'name': string;
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectBody.attributeTypeMap;
    }
}

export class Projects {
    'links': Links;
    'items': Array<Project>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return Projects.attributeTypeMap;
    }
}

/**
* A resource specifier string
*/
export class Resource {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Resource.attributeTypeMap;
    }
}

export class Resources extends Array<Resource> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Resources.attributeTypeMap);
    }
}

export class Role {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}

export class Rollout {
    'variations': Array<WeightedVariation>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<WeightedVariation>"
        }    ];

    static getAttributeTypeMap() {
        return Rollout.attributeTypeMap;
    }
}

export class Rule {
    'id': string;
    'variation': number;
    'rollout': Rollout;
    'clauses': Array<Clause>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        },
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        }    ];

    static getAttributeTypeMap() {
        return Rule.attributeTypeMap;
    }
}

export class Statement {
    'resources': Resources;
    /**
    * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
    */
    'notresources': Resources;
    'actions': Actions;
    /**
    * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
    */
    'notactions': Actions;
    'effect': Statement.EffectEnum;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Resources"
        },
        {
            "name": "notresources",
            "baseName": "notresources",
            "type": "Resources"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Actions"
        },
        {
            "name": "notactions",
            "baseName": "notactions",
            "type": "Actions"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "Statement.EffectEnum"
        }    ];

    static getAttributeTypeMap() {
        return Statement.attributeTypeMap;
    }
}

export namespace Statement {
    export enum EffectEnum {
        Allow = <any> 'allow',
        Deny = <any> 'deny'
    }
}
export class Statements extends Array<Statement> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Statements.attributeTypeMap);
    }
}

export class Target {
    'values': Array<string>;
    'variation': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Target.attributeTypeMap;
    }
}

export class User {
    'key': string;
    'secondary': string;
    'ip': string;
    'country': string;
    'email': string;
    'firstName': string;
    'lastName': string;
    'avatar': string;
    'name': string;
    'anonymous': boolean;
    'custom': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "secondary",
            "baseName": "secondary",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "anonymous",
            "baseName": "anonymous",
            "type": "boolean"
        },
        {
            "name": "custom",
            "baseName": "custom",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserFlagSetting {
    'links': Links;
    /**
    * The most important attribute in the response. The _value is the current setting for the user. For a boolean feature toggle, this will be true, false, or null if there is no defined fallthrough value.
    */
    'value': boolean;
    /**
    * The setting attribute indicates whether you've explicitly targeted this user to receive a particular variation. For example, if you have explicitly turned off a feature toggle for a user, setting will be false. A setting of null means that you haven't assigned that user to a specific variation.
    */
    'setting': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "value",
            "baseName": "_value",
            "type": "boolean"
        },
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSetting.attributeTypeMap;
    }
}

export class UserFlagSettings {
    'links': Links;
    'items': { [key: string]: UserFlagSetting; };

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "{ [key: string]: UserFlagSetting; }"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSettings.attributeTypeMap;
    }
}

export class UserRecord {
    'lastPing': string;
    'environmentId': string;
    'ownerId': Id;
    'user': User;
    'avatar': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastPing",
            "baseName": "lastPing",
            "type": "string"
        },
        {
            "name": "environmentId",
            "baseName": "environmentId",
            "type": "string"
        },
        {
            "name": "ownerId",
            "baseName": "ownerId",
            "type": "Id"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserRecord.attributeTypeMap;
    }
}

export class UserSegment {
    /**
    * Unique identifier for the user segment.
    */
    'key': string;
    /**
    * Name of the user segment.
    */
    'name': string;
    /**
    * Description of the user segment.
    */
    'description': string;
    /**
    * An array of tags for this user segment.
    */
    'tags': Array<string>;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate': number;
    /**
    * An array of user keys that are included in this segment.
    */
    'included': Array<string>;
    /**
    * An array of user keys that should not be included in this segment, unless they are also listed in \"included\".
    */
    'excluded': Array<string>;
    /**
    * An array of rules that can cause a user to be included in this segment.
    */
    'rules': Array<UserSegmentRule>;
    'version': number;
    'links': Links;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "included",
            "baseName": "included",
            "type": "Array<string>"
        },
        {
            "name": "excluded",
            "baseName": "excluded",
            "type": "Array<string>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<UserSegmentRule>"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        }    ];

    static getAttributeTypeMap() {
        return UserSegment.attributeTypeMap;
    }
}

export class UserSegmentBody {
    /**
    * A human-friendly name for the user segment.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the user segment in feature flags.
    */
    'key': string;
    /**
    * A description for the user segment.
    */
    'description': string;
    /**
    * Tags for the user segment.
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentBody.attributeTypeMap;
    }
}

export class UserSegmentRule {
    'clauses': Array<Clause>;
    'weight': number;
    'bucketBy': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        },
        {
            "name": "bucketBy",
            "baseName": "bucketBy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentRule.attributeTypeMap;
    }
}

export class UserSegments {
    'links': Links;
    'items': Array<UserSegment>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserSegment>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegments.attributeTypeMap;
    }
}

export class UserSettingsBody {
    /**
    * The variation value to set for the user. Must match the variation type of the flag. 
    */
    'setting': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserSettingsBody.attributeTypeMap;
    }
}

export class Users {
    'links': Links;
    'totalCount': number;
    'items': Array<UserRecord>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserRecord>"
        }    ];

    static getAttributeTypeMap() {
        return Users.attributeTypeMap;
    }
}

export class Variation {
    'name': string;
    'description': string;
    'value': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Variation.attributeTypeMap;
    }
}

export class Webhook {
    'links': Links;
    'id': Id;
    /**
    * The URL of the remote webhook.
    */
    'url': string;
    /**
    * If defined, the webhooks post request will include a X-LD-Signature header whose value will contain an HMAC SHA256 hex digest of the webhook payload, using the secret as the key.
    */
    'secret': string;
    /**
    * Whether this webhook is enabled or not.
    */
    'on': boolean;
    /**
    * The name of the webhook.
    */
    'name': string;
    /**
    * Tags assigned to this webhook.
    */
    'tags': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Webhook.attributeTypeMap;
    }
}

export class WebhookBody {
    /**
    * The URL of the remote webhook.
    */
    'url': string;
    /**
    * If sign is true, and the secret attribute is omitted, LaunchDarkly will automatically generate a secret for you.
    */
    'secret': string;
    /**
    * If sign is false, the webhook will not include a signature header, and the secret can be omitted.
    */
    'sign': boolean;
    /**
    * Whether this webhook is enabled or not.
    */
    'on': boolean;
    /**
    * The name of the webhook.
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "sign",
            "baseName": "sign",
            "type": "boolean"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookBody.attributeTypeMap;
    }
}

export class Webhooks {
    'links': Links;
    'items': Array<Webhook>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Webhook>"
        }    ];

    static getAttributeTypeMap() {
        return Webhooks.attributeTypeMap;
    }
}

export class WeightedVariation {
    'variation': number;
    'weight': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WeightedVariation.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "FeatureFlagStatus.NameEnum": FeatureFlagStatus.NameEnum,
        "Statement.EffectEnum": Statement.EffectEnum,
}

let typeMap: {[index: string]: any} = {
    "Action": Action,
    "Actions": Actions,
    "AuditLogEntries": AuditLogEntries,
    "AuditLogEntry": AuditLogEntry,
    "AuditLogEntryTarget": AuditLogEntryTarget,
    "Clause": Clause,
    "CustomProperties": CustomProperties,
    "CustomProperty": CustomProperty,
    "CustomPropertyValues": CustomPropertyValues,
    "CustomRole": CustomRole,
    "CustomRoleBody": CustomRoleBody,
    "CustomRoleKeyOrId": CustomRoleKeyOrId,
    "CustomRoles": CustomRoles,
    "Environment": Environment,
    "EnvironmentBody": EnvironmentBody,
    "Fallthrough": Fallthrough,
    "FeatureFlag": FeatureFlag,
    "FeatureFlagBody": FeatureFlagBody,
    "FeatureFlagConfig": FeatureFlagConfig,
    "FeatureFlagStatus": FeatureFlagStatus,
    "FeatureFlagStatuses": FeatureFlagStatuses,
    "FeatureFlags": FeatureFlags,
    "Id": Id,
    "Link": Link,
    "Links": Links,
    "Member": Member,
    "Members": Members,
    "MembersBody": MembersBody,
    "PatchComment": PatchComment,
    "PatchOperation": PatchOperation,
    "Policy": Policy,
    "Prerequisite": Prerequisite,
    "Project": Project,
    "ProjectBody": ProjectBody,
    "Projects": Projects,
    "Resource": Resource,
    "Resources": Resources,
    "Role": Role,
    "Rollout": Rollout,
    "Rule": Rule,
    "Statement": Statement,
    "Statements": Statements,
    "Target": Target,
    "User": User,
    "UserFlagSetting": UserFlagSetting,
    "UserFlagSettings": UserFlagSettings,
    "UserRecord": UserRecord,
    "UserSegment": UserSegment,
    "UserSegmentBody": UserSegmentBody,
    "UserSegmentRule": UserSegmentRule,
    "UserSegments": UserSegments,
    "UserSettingsBody": UserSettingsBody,
    "Users": Users,
    "Variation": Variation,
    "Webhook": Webhook,
    "WebhookBody": WebhookBody,
    "Webhooks": Webhooks,
    "WeightedVariation": WeightedVariation,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AuditLogApiApiKeys {
    Token,
}

export class AuditLogApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuditLogApiApiKeys, value: string) {
        (this.authentications as any)[AuditLogApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
     * @param before A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occured after this timestamp.
     * @param q Text to search for. You can search for the full or partial name of the resource involved or fullpartial email address of the member who made the change.
     * @param limit A limit on the number of audit log entries to be returned, between 1 and 20.
     * @param spec A resource specifier, allowing you to filter audit log listings by resource.
     */
    public getAuditLogEntries (before?: number, after?: number, q?: string, limit?: number, spec?: string) : Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }> {
        const localVarPath = this.basePath + '/auditlog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (spec !== undefined) {
            localVarQueryParameters['spec'] = ObjectSerializer.serialize(spec, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
     * @param resourceId The resource ID.
     */
    public getAuditLogEntry (resourceId: string) : Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }> {
        const localVarPath = this.basePath + '/auditlog/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getAuditLogEntry.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomRolesApiApiKeys {
    Token,
}

export class CustomRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomRolesApiApiKeys, value: string) {
        (this.authentications as any)[CustomRolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a custom role by key.
     * @param customRoleKey The custom role key.
     */
    public deleteCustomRole (customRoleKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling deleteCustomRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get one custom role by key.
     * @param customRoleKey The custom role key.
     */
    public getCustomRole (customRoleKey: string) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling getCustomRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a complete list of custom roles.
     */
    public getCustomRoles () : Promise<{ response: http.ClientResponse; body: CustomRoles;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a custom role by key.
     * @param customRoleKey The custom role key.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     */
    public patchCustomRole (customRoleKey: string, patchDelta: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling patchCustomRole.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchCustomRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new custom role.
     * @param customRoleBody New role or roles to create.
     */
    public postCustomRole (customRoleBody: CustomRoleBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleBody' is not null or undefined
        if (customRoleBody === null || customRoleBody === undefined) {
            throw new Error('Required parameter customRoleBody was null or undefined when calling postCustomRole.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customRoleBody, "CustomRoleBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EnvironmentsApiApiKeys {
    Token,
}

export class EnvironmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EnvironmentsApiApiKeys, value: string) {
        (this.authentications as any)[EnvironmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an environment in a specific project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     */
    public deleteEnvironment (projectKey: string, environmentKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteEnvironment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an environment given a project and key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     */
    public getEnvironment (projectKey: string, environmentKey: string) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getEnvironment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify an environment by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     */
    public patchEnvironment (projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchEnvironment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new environment in a specified project with a given name, key, and swatch color.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentBody New environment.
     */
    public postEnvironment (projectKey: string, environmentBody: EnvironmentBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postEnvironment.');
        }

        // verify required parameter 'environmentBody' is not null or undefined
        if (environmentBody === null || environmentBody === undefined) {
            throw new Error('Required parameter environmentBody was null or undefined when calling postEnvironment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(environmentBody, "EnvironmentBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeatureFlagsApiApiKeys {
    Token,
}

export class FeatureFlagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeatureFlagsApiApiKeys, value: string) {
        (this.authentications as any)[FeatureFlagsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     */
    public deleteFeatureFlag (projectKey: string, featureFlagKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling deleteFeatureFlag.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single feature flag by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;production will restrict the returned configurations to just your production environment.
     */
    public getFeatureFlag (projectKey: string, featureFlagKey: string, env?: string) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlag.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status for a particular feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     */
    public getFeatureFlagStatus (projectKey: string, environmentKey: string, featureFlagKey: string) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatus.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     */
    public getFeatureFlagStatuses (projectKey: string, environmentKey: string) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatuses.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatuses.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatuses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all features in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;production will restrict the returned configurations to just your production environment.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     */
    public getFeatureFlags (projectKey: string, env?: string, tag?: string) : Promise<{ response: http.ClientResponse; body: FeatureFlags;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlags.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "string");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a feature.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param patchComment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     */
    public patchFeatureFlag (projectKey: string, featureFlagKey: string, patchComment: PatchComment) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'patchComment' is not null or undefined
        if (patchComment === null || patchComment === undefined) {
            throw new Error('Required parameter patchComment was null or undefined when calling patchFeatureFlag.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchComment, "PatchComment")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagBody Create a new feature flag.
     */
    public postFeatureFlag (projectKey: string, featureFlagBody: FeatureFlagBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postFeatureFlag.');
        }

        // verify required parameter 'featureFlagBody' is not null or undefined
        if (featureFlagBody === null || featureFlagBody === undefined) {
            throw new Error('Required parameter featureFlagBody was null or undefined when calling postFeatureFlag.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagBody, "FeatureFlagBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectsApiApiKeys {
    Token,
}

export class ProjectsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectsApiApiKeys, value: string) {
        (this.authentications as any)[ProjectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     */
    public deleteProject (projectKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single project by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     */
    public getProject (projectKey: string) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all projects in the account.
     */
    public getProjects () : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a project by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     */
    public patchProject (projectKey: string, patchDelta: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchProject.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new project with the given key and name.
     * @param projectBody Project keys must be unique within an account.
     */
    public postProject (projectBody: ProjectBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectBody' is not null or undefined
        if (projectBody === null || projectBody === undefined) {
            throw new Error('Required parameter projectBody was null or undefined when calling postProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(projectBody, "ProjectBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RootApiApiKeys {
    Token,
}

export class RootApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RootApiApiKeys, value: string) {
        (this.authentications as any)[RootApiApiKeys[key]].apiKey = value;
    }
    /**
     * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
     */
    public getRoot () : Promise<{ response: http.ClientResponse; body: Links;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Links;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Links");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamMembersApiApiKeys {
    Token,
}

export class TeamMembersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamMembersApiApiKeys, value: string) {
        (this.authentications as any)[TeamMembersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a team member by ID.
     * @param memberId The member ID.
     */
    public deleteMember (memberId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single team member by ID.
     * @param memberId The member ID.
     */
    public getMember (memberId: string) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all members in the account.
     */
    public getMembers () : Promise<{ response: http.ClientResponse; body: Members;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Members;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Members");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a team member by ID.
     * @param memberId The member ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     */
    public patchMember (memberId: string, patchDelta: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling patchMember.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Invite new members.
     * @param membersBody New members to invite.
     */
    public postMembers (membersBody: Array<MembersBody>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'membersBody' is not null or undefined
        if (membersBody === null || membersBody === undefined) {
            throw new Error('Required parameter membersBody was null or undefined when calling postMembers.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(membersBody, "Array<MembersBody>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSegmentsApiApiKeys {
    Token,
}

export class UserSegmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSegmentsApiApiKeys, value: string) {
        (this.authentications as any)[UserSegmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     */
    public deleteUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling deleteUserSegment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single user segment by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     */
    public getUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling getUserSegment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all user segments in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     */
    public getUserSegments (projectKey: string, environmentKey: string, tag?: string) : Promise<{ response: http.ClientResponse; body: UserSegments;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegments.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegments.');
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param patchOnly Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     */
    public patchUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'patchOnly' is not null or undefined
        if (patchOnly === null || patchOnly === undefined) {
            throw new Error('Required parameter patchOnly was null or undefined when calling patchUserSegment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchOnly, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentBody Create a new user segment.
     */
    public postUserSegment (projectKey: string, environmentKey: string, userSegmentBody: UserSegmentBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'userSegmentBody' is not null or undefined
        if (userSegmentBody === null || userSegmentBody === undefined) {
            throw new Error('Required parameter userSegmentBody was null or undefined when calling postUserSegment.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSegmentBody, "UserSegmentBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSettingsApiApiKeys {
    Token,
}

export class UserSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSettingsApiApiKeys, value: string) {
        (this.authentications as any)[UserSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     */
    public getUserFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string) : Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getUserFlagSetting.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSetting");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     */
    public getUserFlagSettings (projectKey: string, environmentKey: string, userKey: string) : Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSettings.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Specifically enable or disable a feature flag for a user based on their key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param userSettingsBody 
     */
    public putFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: UserSettingsBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userSettingsBody' is not null or undefined
        if (userSettingsBody === null || userSettingsBody === undefined) {
            throw new Error('Required parameter userSettingsBody was null or undefined when calling putFlagSetting.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSettingsBody, "UserSettingsBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    Token,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     */
    public deleteUser (projectKey: string, environmentKey: string, userKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling deleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param q Search query.
     * @param limit Pagination limit.
     * @param offset Specifies the first item to return in the collection.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occured after this timestamp.
     */
    public getSearchUsers (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/user-search/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getSearchUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getSearchUsers.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     */
    public getUser (projectKey: string, environmentKey: string, userKey: string) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to 'limit' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param limit Pagination limit.
     * @param h This parameter is required when following \&quot;next\&quot; links.
     * @param scrollId This parameter is required when following \&quot;next\&quot; links.
     */
    public getUsers (projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUsers.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (h !== undefined) {
            localVarQueryParameters['h'] = ObjectSerializer.serialize(h, "string");
        }

        if (scrollId !== undefined) {
            localVarQueryParameters['scrollId'] = ObjectSerializer.serialize(scrollId, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
    Token,
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a webhook by ID.
     * @param resourceId The resource ID.
     */
    public deleteWebhook (resourceId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling deleteWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a webhook by ID.
     * @param resourceId The resource ID.
     */
    public getWebhook (resourceId: string) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of all webhooks.
     */
    public getWebhooks () : Promise<{ response: http.ClientResponse; body: Webhooks;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhooks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhooks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a webhook by ID.
     * @param resourceId The resource ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     */
    public patchWebhook (resourceId: string, patchDelta: Array<PatchOperation>) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling patchWebhook.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a webhook.
     * @param webhookBody New webhook.
     */
    public postWebhook (webhookBody: WebhookBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookBody' is not null or undefined
        if (webhookBody === null || webhookBody === undefined) {
            throw new Error('Required parameter webhookBody was null or undefined when calling postWebhook.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookBody, "WebhookBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
