/**
 * LaunchDarkly REST API
 * Build custom integrations with the LaunchDarkly REST API
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://app.launchdarkly.com/api/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AuditLogEntries {
    'links'?: Links;
    'items'?: Array<AuditLogEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AuditLogEntry>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntries.attributeTypeMap;
    }
}

export class AuditLogEntry {
    'links'?: Links;
    'id'?: Id;
    'date'?: number;
    'kind'?: string;
    'name'?: string;
    'description'?: string;
    'shortDescription'?: string;
    'comment'?: string;
    'member'?: Member;
    'titleVerb'?: string;
    'title'?: string;
    'target'?: AuditLogEntryTarget;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "Member"
        },
        {
            "name": "titleVerb",
            "baseName": "titleVerb",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "AuditLogEntryTarget"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntry.attributeTypeMap;
    }
}

export class AuditLogEntryTarget {
    'links'?: Links;
    'name'?: string;
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntryTarget.attributeTypeMap;
    }
}

export class Clause {
    'attribute'?: string;
    'op'?: string;
    'values'?: Array<any>;
    'negate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attribute",
            "baseName": "attribute",
            "type": "string"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<any>"
        },
        {
            "name": "negate",
            "baseName": "negate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Clause.attributeTypeMap;
    }
}

export class CopyActions {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CopyActions.attributeTypeMap;
    }
}

/**
* A name and value describing a custom property.
*/
export class CustomProperty {
    /**
    * The name of the property.
    */
    'name': string;
    /**
    * Values for this property.
    */
    'value'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomProperty.attributeTypeMap;
    }
}

/**
* Values for this property.
*/
export class CustomPropertyValues extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class CustomRole {
    'links'?: Links;
    /**
    * Name of the custom role.
    */
    'name'?: string;
    /**
    * The 20-hexdigit id or the key for a custom role.
    */
    'key'?: string;
    /**
    * Description of the custom role.
    */
    'description'?: string;
    'id'?: Id;
    'policy'?: Array<Policy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRole.attributeTypeMap;
    }
}

export class CustomRoleBody {
    /**
    * Name of the custom role.
    */
    'name': string;
    /**
    * Description of the custom role.
    */
    'description'?: string;
    /**
    * The 20-hexdigit id or the key for a custom role.
    */
    'key': string;
    'policy': Array<Policy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoleBody.attributeTypeMap;
    }
}

export class CustomRoles {
    'links'?: Links;
    'items'?: Array<CustomRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CustomRole>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoles.attributeTypeMap;
    }
}

/**
* Default values to be used when a new environment is created.
*/
export class Defaults {
    /**
    * The index of the variation to be served when a flag's targeting is on (default variation).
    */
    'onVariation': number;
    /**
    * The index of the variation to be served when a flag is off.
    */
    'offVariation': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "onVariation",
            "baseName": "onVariation",
            "type": "number"
        },
        {
            "name": "offVariation",
            "baseName": "offVariation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Defaults.attributeTypeMap;
    }
}

export class Destination {
    'links'?: Links;
    /**
    * Unique destination ID.
    */
    'id'?: string;
    /**
    * The destination name
    */
    'name'?: string;
    /**
    * Destination type (\"google-pubsub\", \"kinesis\", \"mparticle\", or \"segment\")
    */
    'kind'?: Destination.KindEnum;
    /**
    * destination-specific configuration.
    */
    'config'?: any;
    /**
    * Whether the data export destination is on or not.
    */
    'on'?: boolean;
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "Destination.KindEnum"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Destination.attributeTypeMap;
    }
}

export namespace Destination {
    export enum KindEnum {
        GooglePubsub = <any> 'google-pubsub',
        Kinesis = <any> 'kinesis',
        Mparticle = <any> 'mparticle',
        Segment = <any> 'segment'
    }
}
export class DestinationAmazonKinesis {
    'region'?: string;
    'roleArn'?: string;
    'streamName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "roleArn",
            "baseName": "roleArn",
            "type": "string"
        },
        {
            "name": "streamName",
            "baseName": "streamName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationAmazonKinesis.attributeTypeMap;
    }
}

export class DestinationBody {
    /**
    * A human-readable name for your data export destination.
    */
    'name': string;
    /**
    * The data export destination type. Available choices are kinesis, google-pubsub, mparticle, or segment.
    */
    'kind': DestinationBody.KindEnum;
    /**
    * destination-specific configuration.
    */
    'config': any;
    /**
    * Whether the data export destination is on or not.
    */
    'on'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "DestinationBody.KindEnum"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DestinationBody.attributeTypeMap;
    }
}

export namespace DestinationBody {
    export enum KindEnum {
        GooglePubsub = <any> 'google-pubsub',
        Kinesis = <any> 'kinesis',
        Mparticle = <any> 'mparticle',
        Segment = <any> 'segment'
    }
}
export class DestinationGooglePubSub {
    'project'?: string;
    'topic'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "topic",
            "baseName": "topic",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationGooglePubSub.attributeTypeMap;
    }
}

export class DestinationMParticle {
    'apiKey'?: string;
    'secret'?: string;
    'userIdentity'?: string;
    'environment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "userIdentity",
            "baseName": "userIdentity",
            "type": "string"
        },
        {
            "name": "environment",
            "baseName": "environment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationMParticle.attributeTypeMap;
    }
}

export class DestinationSegment {
    'writeKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "writeKey",
            "baseName": "writeKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationSegment.attributeTypeMap;
    }
}

export class Destinations {
    'links'?: Links;
    'items'?: Array<Destination>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Destination>"
        }    ];

    static getAttributeTypeMap() {
        return Destinations.attributeTypeMap;
    }
}

export class Environment {
    'links'?: Links;
    'id'?: Id;
    /**
    * The key for the environment.
    */
    'key'?: string;
    /**
    * The name of the environment.
    */
    'name'?: string;
    /**
    * The SDK key for backend LaunchDarkly SDKs.
    */
    'apiKey'?: string;
    /**
    * The SDK key for mobile LaunchDarkly SDKs.
    */
    'mobileKey'?: string;
    /**
    * The swatch color for the environment.
    */
    'color'?: string;
    /**
    * The default TTL.
    */
    'defaultTtl'?: number;
    /**
    * Determines if this environment is in safe mode.
    */
    'secureMode'?: boolean;
    /**
    * Set to true to send detailed event information for new flags.
    */
    'defaultTrackEvents'?: boolean;
    /**
    * An array of tags for this environment.
    */
    'tags'?: Array<string>;
    /**
    * Determines if this environment requires comments for flag and segment changes.
    */
    'requireComments'?: boolean;
    /**
    * Determines if this environment requires confirmation for flag and segment changes.
    */
    'confirmChanges'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "mobileKey",
            "baseName": "mobileKey",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        },
        {
            "name": "secureMode",
            "baseName": "secureMode",
            "type": "boolean"
        },
        {
            "name": "defaultTrackEvents",
            "baseName": "defaultTrackEvents",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "requireComments",
            "baseName": "requireComments",
            "type": "boolean"
        },
        {
            "name": "confirmChanges",
            "baseName": "confirmChanges",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Environment.attributeTypeMap;
    }
}

export class EnvironmentPost {
    /**
    * The name of the new environment.
    */
    'name': string;
    /**
    * A project-unique key for the new environment.
    */
    'key': string;
    /**
    * A color swatch (as an RGB hex value with no leading '#', e.g. C8C8C8).
    */
    'color': string;
    /**
    * The default TTL for the new environment.
    */
    'defaultTtl'?: number;
    /**
    * Determines whether the environment is in secure mode.
    */
    'secureMode'?: boolean;
    /**
    * Set to true to send detailed event information for newly created flags.
    */
    'defaultTrackEvents'?: boolean;
    /**
    * An array of tags for this environment.
    */
    'tags'?: Array<string>;
    /**
    * Determines if this environment requires comments for flag and segment changes.
    */
    'requireComments'?: boolean;
    /**
    * Determines if this environment requires confirmation for flag and segment changes.
    */
    'confirmChanges'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        },
        {
            "name": "secureMode",
            "baseName": "secureMode",
            "type": "boolean"
        },
        {
            "name": "defaultTrackEvents",
            "baseName": "defaultTrackEvents",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "requireComments",
            "baseName": "requireComments",
            "type": "boolean"
        },
        {
            "name": "confirmChanges",
            "baseName": "confirmChanges",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EnvironmentPost.attributeTypeMap;
    }
}

export class EvaluationUsageError {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EvaluationUsageError.attributeTypeMap;
    }
}

export class Events {
    'links'?: UsageLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "links",
            "type": "UsageLinks"
        }    ];

    static getAttributeTypeMap() {
        return Events.attributeTypeMap;
    }
}

export class Fallthrough {
    'variation'?: number;
    'rollout'?: Rollout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        }    ];

    static getAttributeTypeMap() {
        return Fallthrough.attributeTypeMap;
    }
}

export class FeatureFlag {
    'key'?: string;
    /**
    * Name of the feature flag.
    */
    'name'?: string;
    /**
    * Description of the feature flag.
    */
    'description'?: string;
    /**
    * Whether the feature flag is a boolean flag or multivariate.
    */
    'kind'?: string;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate'?: number;
    'includeInSnippet'?: boolean;
    /**
    * Whether or not this flag is temporary.
    */
    'temporary'?: boolean;
    /**
    * The ID of the member that should maintain this flag.
    */
    'maintainerId'?: string;
    /**
    * An array of tags for this feature flag.
    */
    'tags'?: Array<string>;
    /**
    * The variations for this feature flag.
    */
    'variations'?: Array<Variation>;
    /**
    * An array goals from all environments associated with this feature flag
    */
    'goalIds'?: Array<string>;
    'version'?: number;
    /**
    * A mapping of keys to CustomProperty entries.
    */
    'customProperties'?: { [key: string]: CustomProperty; };
    'links'?: Links;
    'maintainer'?: Member;
    'environments'?: { [key: string]: FeatureFlagConfig; };
    /**
    * A unix epoch time in milliseconds specifying the archived time of this flag.
    */
    'archivedDate'?: number;
    /**
    * Whether or not this flag is archived.
    */
    'archived'?: boolean;
    'defaults'?: Defaults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "maintainerId",
            "baseName": "maintainerId",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "goalIds",
            "baseName": "goalIds",
            "type": "Array<string>"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        },
        {
            "name": "customProperties",
            "baseName": "customProperties",
            "type": "{ [key: string]: CustomProperty; }"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "maintainer",
            "baseName": "_maintainer",
            "type": "Member"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "{ [key: string]: FeatureFlagConfig; }"
        },
        {
            "name": "archivedDate",
            "baseName": "archivedDate",
            "type": "number"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "defaults",
            "baseName": "defaults",
            "type": "Defaults"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlag.attributeTypeMap;
    }
}

export class FeatureFlagBody {
    /**
    * A human-friendly name for the feature flag. Remember to note if this flag is intended to be temporary or permanent.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the flag in your code.
    */
    'key': string;
    /**
    * A description of the feature flag.
    */
    'description'?: string;
    /**
    * An array of possible variations for the flag.
    */
    'variations': Array<Variation>;
    /**
    * Whether or not the flag is a temporary flag.
    */
    'temporary'?: boolean;
    /**
    * Tags for the feature flag.
    */
    'tags'?: Array<string>;
    /**
    * Whether or not this flag should be made available to the client-side JavaScript SDK.
    */
    'includeInSnippet'?: boolean;
    'defaults'?: Defaults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        },
        {
            "name": "defaults",
            "baseName": "defaults",
            "type": "Defaults"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagBody.attributeTypeMap;
    }
}

export class FeatureFlagConfig {
    'on'?: boolean;
    'archived'?: boolean;
    'salt'?: string;
    'sel'?: string;
    'lastModified'?: number;
    'version'?: number;
    'targets'?: Array<Target>;
    'rules'?: Array<Rule>;
    'fallthrough'?: Fallthrough;
    'offVariation'?: number;
    'prerequisites'?: Array<Prerequisite>;
    /**
    * Set to true to send detailed event information for this flag.
    */
    'trackEvents'?: boolean;
    /**
    * Set to true to send detailed event information when targeting is enabled but no individual targeting rule is matched.
    */
    'trackEventsFallthrough'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "salt",
            "baseName": "salt",
            "type": "string"
        },
        {
            "name": "sel",
            "baseName": "sel",
            "type": "string"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "targets",
            "baseName": "targets",
            "type": "Array<Target>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<Rule>"
        },
        {
            "name": "fallthrough",
            "baseName": "fallthrough",
            "type": "Fallthrough"
        },
        {
            "name": "offVariation",
            "baseName": "offVariation",
            "type": "number"
        },
        {
            "name": "prerequisites",
            "baseName": "prerequisites",
            "type": "Array<Prerequisite>"
        },
        {
            "name": "trackEvents",
            "baseName": "trackEvents",
            "type": "boolean"
        },
        {
            "name": "trackEventsFallthrough",
            "baseName": "trackEventsFallthrough",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagConfig.attributeTypeMap;
    }
}

export class FeatureFlagCopyBody {
    'source'?: FeatureFlagCopyObject;
    'target'?: FeatureFlagCopyObject;
    /**
    * comment will be included in audit log item for change.
    */
    'comment'?: string;
    /**
    * Define the parts of the flag configuration that will be copied.
    */
    'includedActions'?: Array<CopyActions>;
    /**
    * Define the parts of the flag configuration that will not be copied.
    */
    'excludedActions'?: Array<CopyActions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "source",
            "baseName": "source",
            "type": "FeatureFlagCopyObject"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "FeatureFlagCopyObject"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "includedActions",
            "baseName": "includedActions",
            "type": "Array<CopyActions>"
        },
        {
            "name": "excludedActions",
            "baseName": "excludedActions",
            "type": "Array<CopyActions>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagCopyBody.attributeTypeMap;
    }
}

export class FeatureFlagCopyObject {
    /**
    * The environment key to be used.
    */
    'key': string;
    /**
    * If the latest version of the flag matches provided version it will copy, otherwise it will return a conflict.
    */
    'currentVersion'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "currentVersion",
            "baseName": "currentVersion",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagCopyObject.attributeTypeMap;
    }
}

export class FeatureFlagStatus {
    /**
    * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn't been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
    */
    'name'?: FeatureFlagStatus.NameEnum;
    'lastRequested'?: string;
    '_default'?: any;
    'links'?: Links;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "FeatureFlagStatus.NameEnum"
        },
        {
            "name": "lastRequested",
            "baseName": "lastRequested",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "any"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatus.attributeTypeMap;
    }
}

export namespace FeatureFlagStatus {
    export enum NameEnum {
        New = <any> 'new',
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Launched = <any> 'launched'
    }
}
export class FeatureFlagStatusAcrossEnvironments {
    'links'?: Links;
    'key'?: string;
    'environments'?: { [key: string]: FeatureFlagStatusForQueriedEnvironment; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "{ [key: string]: FeatureFlagStatusForQueriedEnvironment; }"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatusAcrossEnvironments.attributeTypeMap;
    }
}

export class FeatureFlagStatusForQueriedEnvironment {
    /**
    * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn't been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
    */
    'name'?: FeatureFlagStatusForQueriedEnvironment.NameEnum;
    'lastRequested'?: string;
    '_default'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "FeatureFlagStatusForQueriedEnvironment.NameEnum"
        },
        {
            "name": "lastRequested",
            "baseName": "lastRequested",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatusForQueriedEnvironment.attributeTypeMap;
    }
}

export namespace FeatureFlagStatusForQueriedEnvironment {
    export enum NameEnum {
        New = <any> 'new',
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Launched = <any> 'launched'
    }
}
export class FeatureFlagStatuses {
    'links'?: Links;
    'items'?: Array<FeatureFlagStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlagStatus>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatuses.attributeTypeMap;
    }
}

export class FeatureFlags {
    'links'?: Links;
    'items'?: Array<FeatureFlag>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlag>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlags.attributeTypeMap;
    }
}

export class FlagListItem {
    'name'?: string;
    'key'?: string;
    'links'?: Links;
    'site'?: Site;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "site",
            "baseName": "_site",
            "type": "Site"
        }    ];

    static getAttributeTypeMap() {
        return FlagListItem.attributeTypeMap;
    }
}

/**
* The unique resource id.
*/
export class Id {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Id.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

export class Links {
    'self'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class MAU {
    'links'?: UsageLinks;
    'metadata'?: Array<StreamBySDKLinksMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "UsageLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamBySDKLinksMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return MAU.attributeTypeMap;
    }
}

export class MAUMetadata {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MAUMetadata.attributeTypeMap;
    }
}

export class MAUbyCategory {
    'links'?: StreamBySDKLinks;
    'metadata'?: Array<MAUMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<MAUMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return MAUbyCategory.attributeTypeMap;
    }
}

export class Member {
    'links'?: Links;
    'id'?: Id;
    'role'?: Role;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'verified'?: boolean;
    'pendingInvite'?: boolean;
    'isBeta'?: boolean;
    'customRoles'?: Array<Id>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "_verified",
            "type": "boolean"
        },
        {
            "name": "pendingInvite",
            "baseName": "_pendingInvite",
            "type": "boolean"
        },
        {
            "name": "isBeta",
            "baseName": "isBeta",
            "type": "boolean"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<Id>"
        }    ];

    static getAttributeTypeMap() {
        return Member.attributeTypeMap;
    }
}

export class Members {
    'links'?: Links;
    'items'?: Array<Member>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Member>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Members.attributeTypeMap;
    }
}

export class MembersBody {
    'email': string;
    'firstName'?: string;
    'lastName'?: string;
    'role'?: Role;
    'customRoles'?: Array<string>;
    'inlineRole'?: Array<Statement>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<string>"
        },
        {
            "name": "inlineRole",
            "baseName": "inlineRole",
            "type": "Array<Statement>"
        }    ];

    static getAttributeTypeMap() {
        return MembersBody.attributeTypeMap;
    }
}

export class PatchComment {
    'comment'?: string;
    'patch'?: Array<PatchOperation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "Array<PatchOperation>"
        }    ];

    static getAttributeTypeMap() {
        return PatchComment.attributeTypeMap;
    }
}

export class PatchOperation {
    'op': string;
    'path': string;
    'value': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return PatchOperation.attributeTypeMap;
    }
}

export class Policy {
    'resources'?: Array<string>;
    /**
    * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
    */
    'notResources'?: Array<string>;
    'actions'?: Array<string>;
    /**
    * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
    */
    'notActions'?: Array<string>;
    /**
    * Effect of the policy - allow or deny.
    */
    'effect'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "notResources",
            "baseName": "notResources",
            "type": "Array<string>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<string>"
        },
        {
            "name": "notActions",
            "baseName": "notActions",
            "type": "Array<string>"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Policy.attributeTypeMap;
    }
}

export class Prerequisite {
    'key'?: string;
    'variation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Prerequisite.attributeTypeMap;
    }
}

export class Project {
    'links'?: Links;
    'id'?: Id;
    'key'?: string;
    'name'?: string;
    'includeInSnippetByDefault'?: boolean;
    'environments'?: Array<Environment>;
    /**
    * An array of tags for this project.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "includeInSnippetByDefault",
            "baseName": "includeInSnippetByDefault",
            "type": "boolean"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "Array<Environment>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Project.attributeTypeMap;
    }
}

export class ProjectBody {
    'name': string;
    'key': string;
    'includeInSnippetByDefault'?: boolean;
    'tags'?: Array<string>;
    'environments'?: Array<EnvironmentPost>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "includeInSnippetByDefault",
            "baseName": "includeInSnippetByDefault",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "Array<EnvironmentPost>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectBody.attributeTypeMap;
    }
}

export class Projects {
    'links'?: Links;
    'items'?: Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return Projects.attributeTypeMap;
    }
}

export class Role {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}

export class Rollout {
    'bucketBy'?: string;
    'variations'?: Array<WeightedVariation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bucketBy",
            "baseName": "bucketBy",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<WeightedVariation>"
        }    ];

    static getAttributeTypeMap() {
        return Rollout.attributeTypeMap;
    }
}

export class Rule {
    'id'?: string;
    'variation'?: number;
    'trackEvents'?: boolean;
    'rollout'?: Rollout;
    'clauses'?: Array<Clause>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "trackEvents",
            "baseName": "trackEvents",
            "type": "boolean"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        },
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        }    ];

    static getAttributeTypeMap() {
        return Rule.attributeTypeMap;
    }
}

export class Site {
    'href'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Site.attributeTypeMap;
    }
}

export class Statement {
    'resources'?: Array<string>;
    /**
    * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
    */
    'notResources'?: Array<string>;
    'actions'?: Array<string>;
    /**
    * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
    */
    'notActions'?: Array<string>;
    'effect'?: Statement.EffectEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "notResources",
            "baseName": "notResources",
            "type": "Array<string>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<string>"
        },
        {
            "name": "notActions",
            "baseName": "notActions",
            "type": "Array<string>"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "Statement.EffectEnum"
        }    ];

    static getAttributeTypeMap() {
        return Statement.attributeTypeMap;
    }
}

export namespace Statement {
    export enum EffectEnum {
        Allow = <any> 'allow',
        Deny = <any> 'deny'
    }
}
export class Stream {
    'links'?: StreamUsageLinks;
    'metadata'?: Array<StreamUsageMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamUsageLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamUsageMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return Stream.attributeTypeMap;
    }
}

export class StreamBySDK {
    'links'?: StreamBySDKLinks;
    'metadata'?: Array<StreamBySDKLinksMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamBySDKLinksMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDK.attributeTypeMap;
    }
}

export class StreamBySDKLinks {
    'parent'?: Link;
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDKLinks.attributeTypeMap;
    }
}

export class StreamBySDKLinksMetadata {
    'sdk'?: string;
    'version'?: string;
    'source'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDKLinksMetadata.attributeTypeMap;
    }
}

export class StreamLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * Links to endpoints that are in the request path.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return StreamLinks.attributeTypeMap;
    }
}

export class StreamSDKVersion {
    'links'?: StreamBySDKLinks;
    'sdkVersions'?: Array<StreamSDKVersionData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "sdkVersions",
            "baseName": "sdkVersions",
            "type": "Array<StreamSDKVersionData>"
        }    ];

    static getAttributeTypeMap() {
        return StreamSDKVersion.attributeTypeMap;
    }
}

export class StreamSDKVersionData {
    /**
    * The language of the sdk
    */
    'sdk'?: string;
    /**
    * The version of the sdk
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamSDKVersionData.attributeTypeMap;
    }
}

export class StreamUsageError {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageError.attributeTypeMap;
    }
}

export class StreamUsageLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * The following links that are in the response.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageLinks.attributeTypeMap;
    }
}

export class StreamUsageMetadata {
    /**
    * The language of the sdk
    */
    'sdk'?: string;
    /**
    * The version of the SDK
    */
    'version'?: string;
    'source'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageMetadata.attributeTypeMap;
    }
}

export class StreamUsageSeries {
    /**
    * A key corresponding to a time series data point.
    */
    '_0'?: number;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'time'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_0",
            "baseName": "0",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageSeries.attributeTypeMap;
    }
}

export class Streams {
    'links'?: StreamUsageLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamUsageLinks"
        }    ];

    static getAttributeTypeMap() {
        return Streams.attributeTypeMap;
    }
}

export class Target {
    'values'?: Array<string>;
    'variation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Target.attributeTypeMap;
    }
}

export class Usage {
    'links'?: UsageLinks;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "UsageLinks"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return Usage.attributeTypeMap;
    }
}

export class UsageError {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsageError.attributeTypeMap;
    }
}

export class UsageLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * The following links that are in the response.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return UsageLinks.attributeTypeMap;
    }
}

export class User {
    'key'?: string;
    'secondary'?: string;
    'ip'?: string;
    'country'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'avatar'?: string;
    'name'?: string;
    'anonymous'?: boolean;
    'custom'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "secondary",
            "baseName": "secondary",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "anonymous",
            "baseName": "anonymous",
            "type": "boolean"
        },
        {
            "name": "custom",
            "baseName": "custom",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserFlagSetting {
    'links'?: Links;
    /**
    * The most important attribute in the response. The _value is the current setting for the user. For a boolean feature toggle, this will be true, false, or null if there is no defined fallthrough value.
    */
    'value'?: boolean;
    /**
    * The setting attribute indicates whether you've explicitly targeted this user to receive a particular variation. For example, if you have explicitly turned off a feature toggle for a user, setting will be false. A setting of null means that you haven't assigned that user to a specific variation.
    */
    'setting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "value",
            "baseName": "_value",
            "type": "boolean"
        },
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSetting.attributeTypeMap;
    }
}

export class UserFlagSettings {
    'links'?: Links;
    'items'?: { [key: string]: UserFlagSetting; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "{ [key: string]: UserFlagSetting; }"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSettings.attributeTypeMap;
    }
}

export class UserRecord {
    'lastPing'?: string;
    'environmentId'?: string;
    'ownerId'?: Id;
    'user'?: User;
    'avatar'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastPing",
            "baseName": "lastPing",
            "type": "string"
        },
        {
            "name": "environmentId",
            "baseName": "environmentId",
            "type": "string"
        },
        {
            "name": "ownerId",
            "baseName": "ownerId",
            "type": "Id"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserRecord.attributeTypeMap;
    }
}

export class UserSegment {
    /**
    * Unique identifier for the user segment.
    */
    'key': string;
    /**
    * Name of the user segment.
    */
    'name': string;
    /**
    * Description of the user segment.
    */
    'description'?: string;
    /**
    * An array of tags for this user segment.
    */
    'tags'?: Array<string>;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate': number;
    /**
    * An array of user keys that are included in this segment.
    */
    'included'?: Array<string>;
    /**
    * An array of user keys that should not be included in this segment, unless they are also listed in \"included\".
    */
    'excluded'?: Array<string>;
    /**
    * An array of rules that can cause a user to be included in this segment.
    */
    'rules'?: Array<UserSegmentRule>;
    'version'?: number;
    'links'?: Links;
    'flags'?: Array<FlagListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "included",
            "baseName": "included",
            "type": "Array<string>"
        },
        {
            "name": "excluded",
            "baseName": "excluded",
            "type": "Array<string>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<UserSegmentRule>"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "flags",
            "baseName": "_flags",
            "type": "Array<FlagListItem>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegment.attributeTypeMap;
    }
}

export class UserSegmentBody {
    /**
    * A human-friendly name for the user segment.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the user segment in feature flags.
    */
    'key': string;
    /**
    * A description for the user segment.
    */
    'description'?: string;
    /**
    * Tags for the user segment.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentBody.attributeTypeMap;
    }
}

export class UserSegmentRule {
    'clauses'?: Array<Clause>;
    'weight'?: number;
    'bucketBy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        },
        {
            "name": "bucketBy",
            "baseName": "bucketBy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentRule.attributeTypeMap;
    }
}

export class UserSegments {
    'links'?: Links;
    'items'?: Array<UserSegment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserSegment>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegments.attributeTypeMap;
    }
}

export class UserSettingsBody {
    /**
    * The variation value to set for the user. Must match the variation type of the flag. 
    */
    'setting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserSettingsBody.attributeTypeMap;
    }
}

export class Users {
    'links'?: Links;
    'totalCount'?: number;
    'items'?: Array<UserRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserRecord>"
        }    ];

    static getAttributeTypeMap() {
        return Users.attributeTypeMap;
    }
}

export class Variation {
    'name'?: string;
    'description'?: string;
    'value': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Variation.attributeTypeMap;
    }
}

export class Webhook {
    'links'?: Links;
    'id'?: Id;
    /**
    * The URL of the remote webhook.
    */
    'url'?: string;
    /**
    * If defined, the webhooks post request will include a X-LD-Signature header whose value will contain an HMAC SHA256 hex digest of the webhook payload, using the secret as the key.
    */
    'secret'?: string;
    /**
    * Whether this webhook is enabled or not.
    */
    'on'?: boolean;
    /**
    * The name of the webhook.
    */
    'name'?: string;
    'statements'?: Array<Statement>;
    /**
    * Tags assigned to this webhook.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Webhook.attributeTypeMap;
    }
}

export class WebhookBody {
    /**
    * The URL of the remote webhook.
    */
    'url': string;
    /**
    * If sign is true, and the secret attribute is omitted, LaunchDarkly will automatically generate a secret for you.
    */
    'secret'?: string;
    /**
    * If sign is false, the webhook will not include a signature header, and the secret can be omitted.
    */
    'sign': boolean;
    /**
    * Whether this webhook is enabled or not.
    */
    'on': boolean;
    /**
    * The name of the webhook.
    */
    'name'?: string;
    'statements'?: Array<Statement>;
    /**
    * Tags for the webhook.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "sign",
            "baseName": "sign",
            "type": "boolean"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return WebhookBody.attributeTypeMap;
    }
}

export class Webhooks {
    'links'?: Links;
    'items'?: Array<Webhook>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Webhook>"
        }    ];

    static getAttributeTypeMap() {
        return Webhooks.attributeTypeMap;
    }
}

export class WeightedVariation {
    'variation'?: number;
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WeightedVariation.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Destination.KindEnum": Destination.KindEnum,
        "DestinationBody.KindEnum": DestinationBody.KindEnum,
        "FeatureFlagStatus.NameEnum": FeatureFlagStatus.NameEnum,
        "FeatureFlagStatusForQueriedEnvironment.NameEnum": FeatureFlagStatusForQueriedEnvironment.NameEnum,
        "Statement.EffectEnum": Statement.EffectEnum,
}

let typeMap: {[index: string]: any} = {
    "AuditLogEntries": AuditLogEntries,
    "AuditLogEntry": AuditLogEntry,
    "AuditLogEntryTarget": AuditLogEntryTarget,
    "Clause": Clause,
    "CopyActions": CopyActions,
    "CustomProperty": CustomProperty,
    "CustomPropertyValues": CustomPropertyValues,
    "CustomRole": CustomRole,
    "CustomRoleBody": CustomRoleBody,
    "CustomRoles": CustomRoles,
    "Defaults": Defaults,
    "Destination": Destination,
    "DestinationAmazonKinesis": DestinationAmazonKinesis,
    "DestinationBody": DestinationBody,
    "DestinationGooglePubSub": DestinationGooglePubSub,
    "DestinationMParticle": DestinationMParticle,
    "DestinationSegment": DestinationSegment,
    "Destinations": Destinations,
    "Environment": Environment,
    "EnvironmentPost": EnvironmentPost,
    "EvaluationUsageError": EvaluationUsageError,
    "Events": Events,
    "Fallthrough": Fallthrough,
    "FeatureFlag": FeatureFlag,
    "FeatureFlagBody": FeatureFlagBody,
    "FeatureFlagConfig": FeatureFlagConfig,
    "FeatureFlagCopyBody": FeatureFlagCopyBody,
    "FeatureFlagCopyObject": FeatureFlagCopyObject,
    "FeatureFlagStatus": FeatureFlagStatus,
    "FeatureFlagStatusAcrossEnvironments": FeatureFlagStatusAcrossEnvironments,
    "FeatureFlagStatusForQueriedEnvironment": FeatureFlagStatusForQueriedEnvironment,
    "FeatureFlagStatuses": FeatureFlagStatuses,
    "FeatureFlags": FeatureFlags,
    "FlagListItem": FlagListItem,
    "Id": Id,
    "Link": Link,
    "Links": Links,
    "MAU": MAU,
    "MAUMetadata": MAUMetadata,
    "MAUbyCategory": MAUbyCategory,
    "Member": Member,
    "Members": Members,
    "MembersBody": MembersBody,
    "PatchComment": PatchComment,
    "PatchOperation": PatchOperation,
    "Policy": Policy,
    "Prerequisite": Prerequisite,
    "Project": Project,
    "ProjectBody": ProjectBody,
    "Projects": Projects,
    "Role": Role,
    "Rollout": Rollout,
    "Rule": Rule,
    "Site": Site,
    "Statement": Statement,
    "Stream": Stream,
    "StreamBySDK": StreamBySDK,
    "StreamBySDKLinks": StreamBySDKLinks,
    "StreamBySDKLinksMetadata": StreamBySDKLinksMetadata,
    "StreamLinks": StreamLinks,
    "StreamSDKVersion": StreamSDKVersion,
    "StreamSDKVersionData": StreamSDKVersionData,
    "StreamUsageError": StreamUsageError,
    "StreamUsageLinks": StreamUsageLinks,
    "StreamUsageMetadata": StreamUsageMetadata,
    "StreamUsageSeries": StreamUsageSeries,
    "Streams": Streams,
    "Target": Target,
    "Usage": Usage,
    "UsageError": UsageError,
    "UsageLinks": UsageLinks,
    "User": User,
    "UserFlagSetting": UserFlagSetting,
    "UserFlagSettings": UserFlagSettings,
    "UserRecord": UserRecord,
    "UserSegment": UserSegment,
    "UserSegmentBody": UserSegmentBody,
    "UserSegmentRule": UserSegmentRule,
    "UserSegments": UserSegments,
    "UserSettingsBody": UserSettingsBody,
    "Users": Users,
    "Variation": Variation,
    "Webhook": Webhook,
    "WebhookBody": WebhookBody,
    "Webhooks": Webhooks,
    "WeightedVariation": WeightedVariation,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AuditLogApiApiKeys {
    Token,
}

export class AuditLogApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuditLogApiApiKeys, value: string) {
        (this.authentications as any)[AuditLogApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
     * @param before A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occured after this timestamp.
     * @param q Text to search for. You can search for the full or partial name of the resource involved or fullpartial email address of the member who made the change.
     * @param limit A limit on the number of audit log entries to be returned, between 1 and 20.
     * @param spec A resource specifier, allowing you to filter audit log listings by resource.
     * @param {*} [options] Override http request options.
     */
    public getAuditLogEntries (before?: number, after?: number, q?: string, limit?: number, spec?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }> {
        const localVarPath = this.basePath + '/auditlog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (spec !== undefined) {
            localVarQueryParameters['spec'] = ObjectSerializer.serialize(spec, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public getAuditLogEntry (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }> {
        const localVarPath = this.basePath + '/auditlog/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getAuditLogEntry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomRolesApiApiKeys {
    Token,
}

export class CustomRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomRolesApiApiKeys, value: string) {
        (this.authentications as any)[CustomRolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a custom role by key.
     * @param customRoleKey The custom role key.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomRole (customRoleKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling deleteCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get one custom role by key.
     * @param customRoleKey The custom role key.
     * @param {*} [options] Override http request options.
     */
    public getCustomRole (customRoleKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling getCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a complete list of custom roles.
     * @param {*} [options] Override http request options.
     */
    public getCustomRoles (options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRoles;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a custom role by key.
     * @param customRoleKey The custom role key.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchCustomRole (customRoleKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling patchCustomRole.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new custom role.
     * @param customRoleBody New role or roles to create.
     * @param {*} [options] Override http request options.
     */
    public postCustomRole (customRoleBody: CustomRoleBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleBody' is not null or undefined
        if (customRoleBody === null || customRoleBody === undefined) {
            throw new Error('Required parameter customRoleBody was null or undefined when calling postCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customRoleBody, "CustomRoleBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerMetricsApiApiKeys {
    Token,
}

export class CustomerMetricsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerMetricsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerMetricsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get events usage by event id and the feature flag key.
     * @param envId The environment id for the flag evaluations in question.
     * @param flagKey The key of the flag we want metrics for.
     * @param {*} [options] Override http request options.
     */
    public getEvaluations (envId: string, flagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/evaluations/{envId}/{flagKey}'
            .replace('{' + 'envId' + '}', encodeURIComponent(String(envId)))
            .replace('{' + 'flagKey' + '}', encodeURIComponent(String(flagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'envId' is not null or undefined
        if (envId === null || envId === undefined) {
            throw new Error('Required parameter envId was null or undefined when calling getEvaluations.');
        }

        // verify required parameter 'flagKey' is not null or undefined
        if (flagKey === null || flagKey === undefined) {
            throw new Error('Required parameter flagKey was null or undefined when calling getEvaluations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events usage by event type.
     * @param type The type of event we would like to track.
     * @param {*} [options] Override http request options.
     */
    public getEvent (type: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/events/{type}'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events usage endpoints.
     * @param {*} [options] Override http request options.
     */
    public getEvents (options: any = {}) : Promise<{ response: http.ClientResponse; body: Events;  }> {
        const localVarPath = this.basePath + '/usage/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get monthly active user data.
     * @param {*} [options] Override http request options.
     */
    public getMAU (options: any = {}) : Promise<{ response: http.ClientResponse; body: MAU;  }> {
        const localVarPath = this.basePath + '/usage/mau';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MAU;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MAU");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get monthly active user data by category.
     * @param {*} [options] Override http request options.
     */
    public getMAUByCategory (options: any = {}) : Promise<{ response: http.ClientResponse; body: MAUbyCategory;  }> {
        const localVarPath = this.basePath + '/usage/mau/bycategory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MAUbyCategory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MAUbyCategory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream endpoint and return timeseries data.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStream (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Stream;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStream.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Stream;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Stream");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream timeseries data by source show sdk version metadata.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStreamBySDK (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamBySDK;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}/bysdkversion'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStreamBySDK.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamBySDK;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamBySDK");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream timeseries data by source and show all sdk version associated.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStreamSDKVersion (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}/sdkversions'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStreamSDKVersion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all streams.
     * @param {*} [options] Override http request options.
     */
    public getStreams (options: any = {}) : Promise<{ response: http.ClientResponse; body: Streams;  }> {
        const localVarPath = this.basePath + '/usage/streams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Streams;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Streams");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns of the usage endpoints available.
     * @param {*} [options] Override http request options.
     */
    public getUsage (options: any = {}) : Promise<{ response: http.ClientResponse; body: Usage;  }> {
        const localVarPath = this.basePath + '/usage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Usage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Usage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataExportDestinationsApiApiKeys {
    Token,
}

export class DataExportDestinationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DataExportDestinationsApiApiKeys, value: string) {
        (this.authentications as any)[DataExportDestinationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a single data export destination by ID
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param {*} [options] Override http request options.
     */
    public deleteDestination (projectKey: string, environmentKey: string, destinationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling deleteDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single data export destination by ID
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param {*} [options] Override http request options.
     */
    public getDestination (projectKey: string, environmentKey: string, destinationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling getDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all data export destinations.
     * @param {*} [options] Override http request options.
     */
    public getDestinations (options: any = {}) : Promise<{ response: http.ClientResponse; body: Destinations;  }> {
        const localVarPath = this.basePath + '/destinations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destinations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destinations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a data export destination.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param patchOnly Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchDestination (projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'patchOnly' is not null or undefined
        if (patchOnly === null || patchOnly === undefined) {
            throw new Error('Required parameter patchOnly was null or undefined when calling patchDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchOnly, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new data export destination
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationBody Create a new data export destination.
     * @param {*} [options] Override http request options.
     */
    public postDestination (projectKey: string, environmentKey: string, destinationBody: DestinationBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postDestination.');
        }

        // verify required parameter 'destinationBody' is not null or undefined
        if (destinationBody === null || destinationBody === undefined) {
            throw new Error('Required parameter destinationBody was null or undefined when calling postDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(destinationBody, "DestinationBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EnvironmentsApiApiKeys {
    Token,
}

export class EnvironmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EnvironmentsApiApiKeys, value: string) {
        (this.authentications as any)[EnvironmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an environment in a specific project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public deleteEnvironment (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an environment given a project and key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getEnvironment (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify an environment by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchEnvironment (projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new environment in a specified project with a given name, key, and swatch color.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentBody New environment.
     * @param {*} [options] Override http request options.
     */
    public postEnvironment (projectKey: string, environmentBody: EnvironmentPost, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postEnvironment.');
        }

        // verify required parameter 'environmentBody' is not null or undefined
        if (environmentBody === null || environmentBody === undefined) {
            throw new Error('Required parameter environmentBody was null or undefined when calling postEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(environmentBody, "EnvironmentPost")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeatureFlagsApiApiKeys {
    Token,
}

export class FeatureFlagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeatureFlagsApiApiKeys, value: string) {
        (this.authentications as any)[FeatureFlagsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param featureFlagCopyBody Copy feature flag configurations between environments.
     * @param {*} [options] Override http request options.
     */
    public copyFeatureFlag (projectKey: string, featureFlagKey: string, featureFlagCopyBody: FeatureFlagCopyBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}/copy'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling copyFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling copyFeatureFlag.');
        }

        // verify required parameter 'featureFlagCopyBody' is not null or undefined
        if (featureFlagCopyBody === null || featureFlagCopyBody === undefined) {
            throw new Error('Required parameter featureFlagCopyBody was null or undefined when calling copyFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagCopyBody, "FeatureFlagCopyBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public deleteFeatureFlag (projectKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling deleteFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single feature flag by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlag (projectKey: string, featureFlagKey: string, env?: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlag.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status for a particular feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatus (projectKey: string, environmentKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status for a particular feature flag across environments
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatusAcrossEnvironments (projectKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatusAcrossEnvironments;  }> {
        const localVarPath = this.basePath + '/flag-status/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatusAcrossEnvironments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatusAcrossEnvironments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatuses (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatuses.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatuses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatuses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all features in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
     * @param archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
     * @param limit The number of objects to return. Defaults to -1, which returns everything.
     * @param number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param filter A comma-separated list of filters. Each filter is of the form field:value.
     * @param sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlags (projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, number?: boolean, filter?: string, sort?: string, tag?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlags;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlags.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "boolean");
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (number !== undefined) {
            localVarQueryParameters['number'] = ObjectSerializer.serialize(number, "boolean");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a feature.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param patchComment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchFeatureFlag (projectKey: string, featureFlagKey: string, patchComment: PatchComment, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'patchComment' is not null or undefined
        if (patchComment === null || patchComment === undefined) {
            throw new Error('Required parameter patchComment was null or undefined when calling patchFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchComment, "PatchComment")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagBody Create a new feature flag.
     * @param clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
     * @param {*} [options] Override http request options.
     */
    public postFeatureFlag (projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postFeatureFlag.');
        }

        // verify required parameter 'featureFlagBody' is not null or undefined
        if (featureFlagBody === null || featureFlagBody === undefined) {
            throw new Error('Required parameter featureFlagBody was null or undefined when calling postFeatureFlag.');
        }

        if (clone !== undefined) {
            localVarQueryParameters['clone'] = ObjectSerializer.serialize(clone, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagBody, "FeatureFlagBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectsApiApiKeys {
    Token,
}

export class ProjectsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectsApiApiKeys, value: string) {
        (this.authentications as any)[ProjectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public deleteProject (projectKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single project by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getProject (projectKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all projects in the account.
     * @param {*} [options] Override http request options.
     */
    public getProjects (options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a project by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchProject (projectKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchProject.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new project with the given key and name.
     * @param projectBody Project keys must be unique within an account.
     * @param {*} [options] Override http request options.
     */
    public postProject (projectBody: ProjectBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectBody' is not null or undefined
        if (projectBody === null || projectBody === undefined) {
            throw new Error('Required parameter projectBody was null or undefined when calling postProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(projectBody, "ProjectBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RootApiApiKeys {
    Token,
}

export class RootApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RootApiApiKeys, value: string) {
        (this.authentications as any)[RootApiApiKeys[key]].apiKey = value;
    }
    /**
     * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
     * @param {*} [options] Override http request options.
     */
    public getRoot (options: any = {}) : Promise<{ response: http.ClientResponse; body: Links;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Links;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Links");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamMembersApiApiKeys {
    Token,
}

export class TeamMembersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamMembersApiApiKeys, value: string) {
        (this.authentications as any)[TeamMembersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a team member by ID.
     * @param memberId The member ID.
     * @param {*} [options] Override http request options.
     */
    public deleteMember (memberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the current team member associated with the token
     * @param {*} [options] Override http request options.
     */
    public getMe (options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single team member by ID.
     * @param memberId The member ID.
     * @param {*} [options] Override http request options.
     */
    public getMember (memberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all members in the account.
     * @param limit The number of objects to return. Defaults to -1, which returns everything.
     * @param number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param filter A comma-separated list of filters. Each filter is of the form field:value.
     * @param sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public getMembers (limit?: number, number?: boolean, filter?: string, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Members;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (number !== undefined) {
            localVarQueryParameters['number'] = ObjectSerializer.serialize(number, "boolean");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Members;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Members");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a team member by ID.
     * @param memberId The member ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchMember (memberId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling patchMember.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Invite new members.
     * @param membersBody New members to invite.
     * @param {*} [options] Override http request options.
     */
    public postMembers (membersBody: Array<MembersBody>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Members;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'membersBody' is not null or undefined
        if (membersBody === null || membersBody === undefined) {
            throw new Error('Required parameter membersBody was null or undefined when calling postMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(membersBody, "Array<MembersBody>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Members;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Members");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSegmentsApiApiKeys {
    Token,
}

export class UserSegmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSegmentsApiApiKeys, value: string) {
        (this.authentications as any)[UserSegmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request options.
     */
    public deleteUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling deleteUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single user segment by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request options.
     */
    public getUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling getUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all user segments in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request options.
     */
    public getUserSegments (projectKey: string, environmentKey: string, tag?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegments;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegments.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegments.');
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param patchOnly Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'patchOnly' is not null or undefined
        if (patchOnly === null || patchOnly === undefined) {
            throw new Error('Required parameter patchOnly was null or undefined when calling patchUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchOnly, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentBody Create a new user segment.
     * @param {*} [options] Override http request options.
     */
    public postUserSegment (projectKey: string, environmentKey: string, userSegmentBody: UserSegmentBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'userSegmentBody' is not null or undefined
        if (userSegmentBody === null || userSegmentBody === undefined) {
            throw new Error('Required parameter userSegmentBody was null or undefined when calling postUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSegmentBody, "UserSegmentBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSettingsApiApiKeys {
    Token,
}

export class UserSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSettingsApiApiKeys, value: string) {
        (this.authentications as any)[UserSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getUserFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getUserFlagSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSetting");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public getUserFlagSettings (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Specifically enable or disable a feature flag for a user based on their key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param userSettingsBody 
     * @param {*} [options] Override http request options.
     */
    public putFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: UserSettingsBody, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userSettingsBody' is not null or undefined
        if (userSettingsBody === null || userSettingsBody === undefined) {
            throw new Error('Required parameter userSettingsBody was null or undefined when calling putFlagSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSettingsBody, "UserSettingsBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    Token,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public deleteUser (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling deleteUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param q Search query.
     * @param limit Pagination limit.
     * @param offset Specifies the first item to return in the collection.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occured after this timestamp.
     * @param {*} [options] Override http request options.
     */
    public getSearchUsers (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/user-search/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getSearchUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getSearchUsers.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public getUser (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to 'limit' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param limit Pagination limit.
     * @param h This parameter is required when following \&quot;next\&quot; links.
     * @param scrollId This parameter is required when following \&quot;next\&quot; links.
     * @param {*} [options] Override http request options.
     */
    public getUsers (projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUsers.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (h !== undefined) {
            localVarQueryParameters['h'] = ObjectSerializer.serialize(h, "string");
        }

        if (scrollId !== undefined) {
            localVarQueryParameters['scrollId'] = ObjectSerializer.serialize(scrollId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
    Token,
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a webhook by ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public deleteWebhook (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling deleteWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a webhook by ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public getWebhook (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of all webhooks.
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhooks;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhooks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhooks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a webhook by ID.
     * @param resourceId The resource ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchWebhook (resourceId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling patchWebhook.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a webhook.
     * @param webhookBody New webhook.
     * @param {*} [options] Override http request options.
     */
    public postWebhook (webhookBody: WebhookBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookBody' is not null or undefined
        if (webhookBody === null || webhookBody === undefined) {
            throw new Error('Required parameter webhookBody was null or undefined when calling postWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookBody, "WebhookBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
