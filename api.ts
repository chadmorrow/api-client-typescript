/**
 * LaunchDarkly REST API
 * Build custom integrations with the LaunchDarkly REST API
 *
 * OpenAPI spec version: 4.0.0
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://app.launchdarkly.com/api/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AuditLogEntries {
    'links'?: Links;
    'items'?: Array<AuditLogEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AuditLogEntry>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntries.attributeTypeMap;
    }
}

export class AuditLogEntry {
    'links'?: Links;
    'id'?: Id;
    'date'?: number;
    'kind'?: string;
    'name'?: string;
    'description'?: string;
    'shortDescription'?: string;
    'comment'?: string;
    'member'?: Member;
    'titleVerb'?: string;
    'title'?: string;
    'target'?: AuditLogEntryTarget;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "Member"
        },
        {
            "name": "titleVerb",
            "baseName": "titleVerb",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "AuditLogEntryTarget"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntry.attributeTypeMap;
    }
}

export class AuditLogEntryTarget {
    'links'?: Links;
    'name'?: string;
    'resources'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AuditLogEntryTarget.attributeTypeMap;
    }
}

export class Clause {
    'id'?: string;
    'attribute'?: string;
    'op'?: string;
    'values'?: Array<any>;
    'negate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "attribute",
            "baseName": "attribute",
            "type": "string"
        },
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<any>"
        },
        {
            "name": "negate",
            "baseName": "negate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Clause.attributeTypeMap;
    }
}

export class ClientSideAvailability {
    /**
    * When set to true, this flag will be available to SDKs using the client-side id.
    */
    'usingEnvironmentId'?: boolean;
    /**
    * When set to true, this flag will be available to SDKS using a mobile key.
    */
    'usingMobileKey'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "usingEnvironmentId",
            "baseName": "usingEnvironmentId",
            "type": "boolean"
        },
        {
            "name": "usingMobileKey",
            "baseName": "usingMobileKey",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ClientSideAvailability.attributeTypeMap;
    }
}

export class CopyActions {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CopyActions.attributeTypeMap;
    }
}

/**
* A name and value describing a custom property.
*/
export class CustomProperty {
    /**
    * The name of the property.
    */
    'name': string;
    /**
    * Values for this property.
    */
    'value'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomProperty.attributeTypeMap;
    }
}

/**
* Values for this property.
*/
export class CustomPropertyValues extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class CustomRole {
    'links'?: Links;
    /**
    * Name of the custom role.
    */
    'name'?: string;
    /**
    * The 20-hexdigit id or the key for a custom role.
    */
    'key'?: string;
    /**
    * Description of the custom role.
    */
    'description'?: string;
    'id'?: Id;
    'policy'?: Array<Policy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRole.attributeTypeMap;
    }
}

export class CustomRoleBody {
    /**
    * Name of the custom role.
    */
    'name': string;
    /**
    * Description of the custom role.
    */
    'description'?: string;
    /**
    * The 20-hexdigit id or the key for a custom role.
    */
    'key': string;
    'policy': Array<Policy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoleBody.attributeTypeMap;
    }
}

export class CustomRoles {
    'links'?: Links;
    'items'?: Array<CustomRole>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CustomRole>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRoles.attributeTypeMap;
    }
}

/**
* Default values to be used when a new environment is created.
*/
export class Defaults {
    /**
    * The index of the variation to be served when a flag's targeting is on (default variation).
    */
    'onVariation': number;
    /**
    * The index of the variation to be served when a flag is off.
    */
    'offVariation': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "onVariation",
            "baseName": "onVariation",
            "type": "number"
        },
        {
            "name": "offVariation",
            "baseName": "offVariation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Defaults.attributeTypeMap;
    }
}

export class Destination {
    'links'?: Links;
    /**
    * Unique destination ID.
    */
    'id'?: string;
    /**
    * The destination name
    */
    'name'?: string;
    /**
    * Destination type (\"google-pubsub\", \"kinesis\", \"mparticle\", or \"segment\")
    */
    'kind'?: Destination.KindEnum;
    /**
    * destination-specific configuration.
    */
    'config'?: any;
    /**
    * Whether the data export destination is on or not.
    */
    'on'?: boolean;
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "Destination.KindEnum"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Destination.attributeTypeMap;
    }
}

export namespace Destination {
    export enum KindEnum {
        GooglePubsub = <any> 'google-pubsub',
        Kinesis = <any> 'kinesis',
        Mparticle = <any> 'mparticle',
        Segment = <any> 'segment'
    }
}
export class DestinationAmazonKinesis {
    'region'?: string;
    'roleArn'?: string;
    'streamName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "roleArn",
            "baseName": "roleArn",
            "type": "string"
        },
        {
            "name": "streamName",
            "baseName": "streamName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationAmazonKinesis.attributeTypeMap;
    }
}

export class DestinationBody {
    /**
    * A human-readable name for your data export destination.
    */
    'name': string;
    /**
    * The data export destination type. Available choices are kinesis, google-pubsub, mparticle, or segment.
    */
    'kind': DestinationBody.KindEnum;
    /**
    * destination-specific configuration.
    */
    'config': any;
    /**
    * Whether the data export destination is on or not.
    */
    'on'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "DestinationBody.KindEnum"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DestinationBody.attributeTypeMap;
    }
}

export namespace DestinationBody {
    export enum KindEnum {
        GooglePubsub = <any> 'google-pubsub',
        Kinesis = <any> 'kinesis',
        Mparticle = <any> 'mparticle',
        Segment = <any> 'segment'
    }
}
export class DestinationGooglePubSub {
    'project'?: string;
    'topic'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "topic",
            "baseName": "topic",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationGooglePubSub.attributeTypeMap;
    }
}

export class DestinationMParticle {
    'apiKey'?: string;
    'secret'?: string;
    'userIdentity'?: string;
    'environment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "userIdentity",
            "baseName": "userIdentity",
            "type": "string"
        },
        {
            "name": "environment",
            "baseName": "environment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationMParticle.attributeTypeMap;
    }
}

export class DestinationSegment {
    'writeKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "writeKey",
            "baseName": "writeKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DestinationSegment.attributeTypeMap;
    }
}

export class Destinations {
    'links'?: Links;
    'items'?: Array<Destination>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Destination>"
        }    ];

    static getAttributeTypeMap() {
        return Destinations.attributeTypeMap;
    }
}

export class Environment {
    'links'?: Links;
    'id'?: Id;
    /**
    * The key for the environment.
    */
    'key'?: string;
    /**
    * The name of the environment.
    */
    'name'?: string;
    /**
    * The SDK key for backend LaunchDarkly SDKs.
    */
    'apiKey'?: string;
    /**
    * The SDK key for mobile LaunchDarkly SDKs.
    */
    'mobileKey'?: string;
    /**
    * The swatch color for the environment.
    */
    'color'?: string;
    /**
    * The default TTL.
    */
    'defaultTtl'?: number;
    /**
    * Determines if this environment is in safe mode.
    */
    'secureMode'?: boolean;
    /**
    * Set to true to send detailed event information for new flags.
    */
    'defaultTrackEvents'?: boolean;
    /**
    * An array of tags for this environment.
    */
    'tags'?: Array<string>;
    /**
    * Determines if this environment requires comments for flag and segment changes.
    */
    'requireComments'?: boolean;
    /**
    * Determines if this environment requires confirmation for flag and segment changes.
    */
    'confirmChanges'?: boolean;
    'approvalSettings'?: EnvironmentApprovalSettings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "mobileKey",
            "baseName": "mobileKey",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        },
        {
            "name": "secureMode",
            "baseName": "secureMode",
            "type": "boolean"
        },
        {
            "name": "defaultTrackEvents",
            "baseName": "defaultTrackEvents",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "requireComments",
            "baseName": "requireComments",
            "type": "boolean"
        },
        {
            "name": "confirmChanges",
            "baseName": "confirmChanges",
            "type": "boolean"
        },
        {
            "name": "approvalSettings",
            "baseName": "approvalSettings",
            "type": "EnvironmentApprovalSettings"
        }    ];

    static getAttributeTypeMap() {
        return Environment.attributeTypeMap;
    }
}

/**
* Approval settings for an environment. Only appears if the approvals feature is enabled.
*/
export class EnvironmentApprovalSettings {
    /**
    * The approvals system used.
    */
    'serviceKind'?: EnvironmentApprovalSettings.ServiceKindEnum;
    /**
    * Whether any changes to flags in this environment will require approval.
    */
    'required'?: boolean;
    /**
    * Whether requesters can approve or decline their own request. They may always comment.
    */
    'canReviewOwnRequest'?: boolean;
    /**
    * The number of approvals required before an approval request can be applied.
    */
    'minNumApprovals'?: number;
    /**
    * Whether changes can be applied as long as minNumApprovals is met, regardless of if any reviewers have declined a request.
    */
    'canApplyDeclinedChanges'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceKind",
            "baseName": "serviceKind",
            "type": "EnvironmentApprovalSettings.ServiceKindEnum"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "canReviewOwnRequest",
            "baseName": "canReviewOwnRequest",
            "type": "boolean"
        },
        {
            "name": "minNumApprovals",
            "baseName": "minNumApprovals",
            "type": "number"
        },
        {
            "name": "canApplyDeclinedChanges",
            "baseName": "canApplyDeclinedChanges",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EnvironmentApprovalSettings.attributeTypeMap;
    }
}

export namespace EnvironmentApprovalSettings {
    export enum ServiceKindEnum {
        Launchdarkly = <any> 'launchdarkly',
        ServiceNow = <any> 'service-now'
    }
}
export class EnvironmentPost {
    /**
    * The name of the new environment.
    */
    'name': string;
    /**
    * A project-unique key for the new environment.
    */
    'key': string;
    /**
    * A color swatch (as an RGB hex value with no leading '#', e.g. C8C8C8).
    */
    'color': string;
    /**
    * The default TTL for the new environment.
    */
    'defaultTtl'?: number;
    /**
    * Determines whether the environment is in secure mode.
    */
    'secureMode'?: boolean;
    /**
    * Set to true to send detailed event information for newly created flags.
    */
    'defaultTrackEvents'?: boolean;
    /**
    * An array of tags for this environment.
    */
    'tags'?: Array<string>;
    /**
    * Determines if this environment requires comments for flag and segment changes.
    */
    'requireComments'?: boolean;
    /**
    * Determines if this environment requires confirmation for flag and segment changes.
    */
    'confirmChanges'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "defaultTtl",
            "baseName": "defaultTtl",
            "type": "number"
        },
        {
            "name": "secureMode",
            "baseName": "secureMode",
            "type": "boolean"
        },
        {
            "name": "defaultTrackEvents",
            "baseName": "defaultTrackEvents",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "requireComments",
            "baseName": "requireComments",
            "type": "boolean"
        },
        {
            "name": "confirmChanges",
            "baseName": "confirmChanges",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EnvironmentPost.attributeTypeMap;
    }
}

export class EvaluationUsageError {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EvaluationUsageError.attributeTypeMap;
    }
}

export class Events {
    'links'?: UsageLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "links",
            "type": "UsageLinks"
        }    ];

    static getAttributeTypeMap() {
        return Events.attributeTypeMap;
    }
}

export class Fallthrough {
    'variation'?: number;
    'rollout'?: Rollout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        }    ];

    static getAttributeTypeMap() {
        return Fallthrough.attributeTypeMap;
    }
}

export class FeatureFlag {
    'key'?: string;
    /**
    * Name of the feature flag.
    */
    'name'?: string;
    /**
    * Description of the feature flag.
    */
    'description'?: string;
    /**
    * Whether the feature flag is a boolean flag or multivariate.
    */
    'kind'?: string;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate'?: number;
    'includeInSnippet'?: boolean;
    /**
    * Whether or not this flag is temporary.
    */
    'temporary'?: boolean;
    /**
    * The ID of the member that should maintain this flag.
    */
    'maintainerId'?: string;
    /**
    * An array of tags for this feature flag.
    */
    'tags'?: Array<string>;
    /**
    * The variations for this feature flag.
    */
    'variations'?: Array<Variation>;
    /**
    * An array goals from all environments associated with this feature flag
    */
    'goalIds'?: Array<string>;
    'version'?: number;
    /**
    * A mapping of keys to CustomProperty entries.
    */
    'customProperties'?: { [key: string]: CustomProperty; };
    'links'?: Links;
    'maintainer'?: Member;
    'environments'?: { [key: string]: FeatureFlagConfig; };
    /**
    * A unix epoch time in milliseconds specifying the archived time of this flag.
    */
    'archivedDate'?: number;
    /**
    * Whether or not this flag is archived.
    */
    'archived'?: boolean;
    'clientSideAvailability'?: ClientSideAvailability;
    'defaults'?: Defaults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "maintainerId",
            "baseName": "maintainerId",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "goalIds",
            "baseName": "goalIds",
            "type": "Array<string>"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        },
        {
            "name": "customProperties",
            "baseName": "customProperties",
            "type": "{ [key: string]: CustomProperty; }"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "maintainer",
            "baseName": "_maintainer",
            "type": "Member"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "{ [key: string]: FeatureFlagConfig; }"
        },
        {
            "name": "archivedDate",
            "baseName": "archivedDate",
            "type": "number"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "clientSideAvailability",
            "baseName": "clientSideAvailability",
            "type": "ClientSideAvailability"
        },
        {
            "name": "defaults",
            "baseName": "defaults",
            "type": "Defaults"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlag.attributeTypeMap;
    }
}

export class FeatureFlagApprovalRequest {
    'id'?: Id;
    'version'?: number;
    /**
    * A unix epoch time in milliseconds specifying the date the approval request was requested
    */
    'creationDate'?: number;
    /**
    * The id of the member that requested the change
    */
    'requestorId'?: string;
    'reviewStatus'?: FeatureFlagApprovalRequestReviewStatus;
    /**
    * | Name     | Description | | --------:| ----------- | | pending  | the feature flag approval request has not been applied yet | | completed| the feature flag approval request has been applied successfully | | failed   | the feature flag approval request has been applied but the changes were not applied successfully | 
    */
    'status'?: FeatureFlagApprovalRequest.StatusEnum;
    /**
    * The id of the member that applied the approval request
    */
    'appliedByMemberID'?: string;
    /**
    * A unix epoch time in milliseconds specifying the date the approval request was applied
    */
    'appliedDate'?: number;
    'allReviews'?: Array<FeatureFlagApprovalRequestReview>;
    'notifyMemberIds'?: Array<string>;
    'instructions'?: SemanticPatchInstruction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "reviewStatus",
            "baseName": "reviewStatus",
            "type": "FeatureFlagApprovalRequestReviewStatus"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "FeatureFlagApprovalRequest.StatusEnum"
        },
        {
            "name": "appliedByMemberID",
            "baseName": "appliedByMemberID",
            "type": "string"
        },
        {
            "name": "appliedDate",
            "baseName": "appliedDate",
            "type": "number"
        },
        {
            "name": "allReviews",
            "baseName": "allReviews",
            "type": "Array<FeatureFlagApprovalRequestReview>"
        },
        {
            "name": "notifyMemberIds",
            "baseName": "notifyMemberIds",
            "type": "Array<string>"
        },
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "SemanticPatchInstruction"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequest.attributeTypeMap;
    }
}

export namespace FeatureFlagApprovalRequest {
    export enum StatusEnum {
        Pending = <any> 'pending',
        Completed = <any> 'completed',
        Failed = <any> 'failed'
    }
}
export class FeatureFlagApprovalRequestApplyConfigBody {
    /**
    * comment will be included in audit log item for change.
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequestApplyConfigBody.attributeTypeMap;
    }
}

export class FeatureFlagApprovalRequestConfigBody {
    /**
    * A name that describes the changes you would like to apply to a feature flag configuration
    */
    'description': string;
    'instructions': SemanticPatchInstruction;
    'notifyMemberIds': Array<string>;
    /**
    * comment will be included in audit log item for change.
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "SemanticPatchInstruction"
        },
        {
            "name": "notifyMemberIds",
            "baseName": "notifyMemberIds",
            "type": "Array<string>"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequestConfigBody.attributeTypeMap;
    }
}

export class FeatureFlagApprovalRequestReview {
    /**
    * A unix epoch time in milliseconds specifying the date the approval request was reviewed
    */
    'creationDate'?: number;
    'kind'?: FeatureFlagApprovalRequestReviewStatus;
    'memberId'?: Id;
    'id'?: Id;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "FeatureFlagApprovalRequestReviewStatus"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "Id"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequestReview.attributeTypeMap;
    }
}

export class FeatureFlagApprovalRequestReviewConfigBody {
    /**
    * One of approve, decline, or comment.
    */
    'kind': FeatureFlagApprovalRequestReviewConfigBody.KindEnum;
    /**
    * comment will be included in audit log item for change.
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "FeatureFlagApprovalRequestReviewConfigBody.KindEnum"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequestReviewConfigBody.attributeTypeMap;
    }
}

export namespace FeatureFlagApprovalRequestReviewConfigBody {
    export enum KindEnum {
        Approve = <any> 'approve',
        Decline = <any> 'decline',
        Comment = <any> 'comment'
    }
}
/**
* | Name     | Description | | --------:| ----------- | | pending  | the feature flag approval request has not been reviewed yet | | approved | the feature flag approval request has been approved and can now be applied | | declined | the feature flag approval request has been declined and cannot be applied | 
*/
export class FeatureFlagApprovalRequestReviewStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequestReviewStatus.attributeTypeMap;
    }
}

export class FeatureFlagApprovalRequests {
    'links'?: Links;
    'items'?: Array<FeatureFlagApprovalRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlagApprovalRequest>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagApprovalRequests.attributeTypeMap;
    }
}

export class FeatureFlagBody {
    /**
    * A human-friendly name for the feature flag. Remember to note if this flag is intended to be temporary or permanent.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the flag in your code.
    */
    'key': string;
    /**
    * A description of the feature flag.
    */
    'description'?: string;
    /**
    * An array of possible variations for the flag.
    */
    'variations': Array<Variation>;
    /**
    * Whether or not the flag is a temporary flag.
    */
    'temporary'?: boolean;
    /**
    * Tags for the feature flag.
    */
    'tags'?: Array<string>;
    /**
    * Whether or not this flag should be made available to the client-side JavaScript SDK.
    */
    'includeInSnippet'?: boolean;
    'clientSideAvailability'?: ClientSideAvailability;
    'defaults'?: Defaults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<Variation>"
        },
        {
            "name": "temporary",
            "baseName": "temporary",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "includeInSnippet",
            "baseName": "includeInSnippet",
            "type": "boolean"
        },
        {
            "name": "clientSideAvailability",
            "baseName": "clientSideAvailability",
            "type": "ClientSideAvailability"
        },
        {
            "name": "defaults",
            "baseName": "defaults",
            "type": "Defaults"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagBody.attributeTypeMap;
    }
}

export class FeatureFlagConfig {
    'on'?: boolean;
    'archived'?: boolean;
    'salt'?: string;
    'sel'?: string;
    'lastModified'?: number;
    'version'?: number;
    'targets'?: Array<Target>;
    'rules'?: Array<Rule>;
    'fallthrough'?: Fallthrough;
    'offVariation'?: number;
    'prerequisites'?: Array<Prerequisite>;
    /**
    * Set to true to send detailed event information for this flag.
    */
    'trackEvents'?: boolean;
    /**
    * Set to true to send detailed event information when targeting is enabled but no individual targeting rule is matched.
    */
    'trackEventsFallthrough'?: boolean;
    'site'?: Site;
    'environmentName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "salt",
            "baseName": "salt",
            "type": "string"
        },
        {
            "name": "sel",
            "baseName": "sel",
            "type": "string"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "targets",
            "baseName": "targets",
            "type": "Array<Target>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<Rule>"
        },
        {
            "name": "fallthrough",
            "baseName": "fallthrough",
            "type": "Fallthrough"
        },
        {
            "name": "offVariation",
            "baseName": "offVariation",
            "type": "number"
        },
        {
            "name": "prerequisites",
            "baseName": "prerequisites",
            "type": "Array<Prerequisite>"
        },
        {
            "name": "trackEvents",
            "baseName": "trackEvents",
            "type": "boolean"
        },
        {
            "name": "trackEventsFallthrough",
            "baseName": "trackEventsFallthrough",
            "type": "boolean"
        },
        {
            "name": "site",
            "baseName": "_site",
            "type": "Site"
        },
        {
            "name": "environmentName",
            "baseName": "_environmentName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagConfig.attributeTypeMap;
    }
}

export class FeatureFlagCopyBody {
    'source'?: FeatureFlagCopyObject;
    'target'?: FeatureFlagCopyObject;
    /**
    * comment will be included in audit log item for change.
    */
    'comment'?: string;
    /**
    * Define the parts of the flag configuration that will be copied.
    */
    'includedActions'?: Array<CopyActions>;
    /**
    * Define the parts of the flag configuration that will not be copied.
    */
    'excludedActions'?: Array<CopyActions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "source",
            "baseName": "source",
            "type": "FeatureFlagCopyObject"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "FeatureFlagCopyObject"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "includedActions",
            "baseName": "includedActions",
            "type": "Array<CopyActions>"
        },
        {
            "name": "excludedActions",
            "baseName": "excludedActions",
            "type": "Array<CopyActions>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagCopyBody.attributeTypeMap;
    }
}

export class FeatureFlagCopyObject {
    /**
    * The environment key to be used.
    */
    'key': string;
    /**
    * If the latest version of the flag matches provided version it will copy, otherwise it will return a conflict.
    */
    'currentVersion'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "currentVersion",
            "baseName": "currentVersion",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagCopyObject.attributeTypeMap;
    }
}

export class FeatureFlagScheduledChange {
    /**
    * A unix epoch time in milliseconds specifying the date the scheduled changes will be applied
    */
    'executionDate'?: number;
    'version'?: number;
    'id'?: string;
    'instructions'?: SemanticPatchInstruction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executionDate",
            "baseName": "executionDate",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "SemanticPatchInstruction"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagScheduledChange.attributeTypeMap;
    }
}

export class FeatureFlagScheduledChanges {
    'links'?: Links;
    'items'?: Array<FeatureFlagScheduledChange>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlagScheduledChange>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagScheduledChanges.attributeTypeMap;
    }
}

export class FeatureFlagScheduledChangesConflicts {
    'instructions'?: Array<FeatureFlagScheduledChangesConflictsInstructions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "Array<FeatureFlagScheduledChangesConflictsInstructions>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagScheduledChangesConflicts.attributeTypeMap;
    }
}

export class FeatureFlagScheduledChangesConflictsInstructions {
    /**
    * The name of the modification you would like to perform on a resource.
    */
    'kind'?: string;
    'conflicts'?: Array<ScheduledChangesFeatureFlagConflict>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "conflicts",
            "baseName": "conflicts",
            "type": "Array<ScheduledChangesFeatureFlagConflict>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagScheduledChangesConflictsInstructions.attributeTypeMap;
    }
}

export class FeatureFlagStatus {
    /**
    * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn't been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
    */
    'name'?: FeatureFlagStatus.NameEnum;
    'lastRequested'?: string;
    '_default'?: any;
    'links'?: Links;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "FeatureFlagStatus.NameEnum"
        },
        {
            "name": "lastRequested",
            "baseName": "lastRequested",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "any"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatus.attributeTypeMap;
    }
}

export namespace FeatureFlagStatus {
    export enum NameEnum {
        New = <any> 'new',
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Launched = <any> 'launched'
    }
}
export class FeatureFlagStatusAcrossEnvironments {
    'links'?: Links;
    'key'?: string;
    'environments'?: { [key: string]: FeatureFlagStatusForQueriedEnvironment; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "{ [key: string]: FeatureFlagStatusForQueriedEnvironment; }"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatusAcrossEnvironments.attributeTypeMap;
    }
}

export class FeatureFlagStatusForQueriedEnvironment {
    /**
    * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn't been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
    */
    'name'?: FeatureFlagStatusForQueriedEnvironment.NameEnum;
    'lastRequested'?: string;
    '_default'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "FeatureFlagStatusForQueriedEnvironment.NameEnum"
        },
        {
            "name": "lastRequested",
            "baseName": "lastRequested",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatusForQueriedEnvironment.attributeTypeMap;
    }
}

export namespace FeatureFlagStatusForQueriedEnvironment {
    export enum NameEnum {
        New = <any> 'new',
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Launched = <any> 'launched'
    }
}
export class FeatureFlagStatuses {
    'links'?: Links;
    'items'?: Array<FeatureFlagStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlagStatus>"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlagStatuses.attributeTypeMap;
    }
}

export class FeatureFlags {
    'links'?: Links;
    'items'?: Array<FeatureFlag>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FeatureFlag>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeatureFlags.attributeTypeMap;
    }
}

export class FlagListItem {
    'name'?: string;
    'key'?: string;
    'links'?: Links;
    'site'?: Site;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "site",
            "baseName": "_site",
            "type": "Site"
        }    ];

    static getAttributeTypeMap() {
        return FlagListItem.attributeTypeMap;
    }
}

export class HierarchicalLinks {
    'parent'?: Link;
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return HierarchicalLinks.attributeTypeMap;
    }
}

/**
* The unique resource id.
*/
export class Id {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Id.attributeTypeMap;
    }
}

export class Integration {
    'links'?: IntegrationLinks;
    'items'?: Array<IntegrationSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "IntegrationLinks"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<IntegrationSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return Integration.attributeTypeMap;
    }
}

export class IntegrationLinks {
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return IntegrationLinks.attributeTypeMap;
    }
}

export class IntegrationSubscription {
    'links'?: HierarchicalLinks;
    'id'?: Id;
    /**
    * The type of integration associated with this configuration.
    */
    'kind'?: string;
    /**
    * The user-defined name associated with this configuration.
    */
    'name'?: string;
    /**
    * A key-value mapping of configuration fields.
    */
    'config'?: any;
    'statements'?: Array<Statement>;
    /**
    * Whether or not the integration is currently active.
    */
    'on'?: boolean;
    /**
    * An array of tags for this integration configuration.
    */
    'tags'?: Array<string>;
    'status'?: IntegrationSubscriptionStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "HierarchicalLinks"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "_status",
            "type": "IntegrationSubscriptionStatus"
        }    ];

    static getAttributeTypeMap() {
        return IntegrationSubscription.attributeTypeMap;
    }
}

export class IntegrationSubscriptionStatus {
    'successCount'?: number;
    /**
    * A unix epoch time in milliseconds specifying the last time this integration was successfully used.
    */
    'lastSuccess'?: number;
    'errorCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "successCount",
            "baseName": "successCount",
            "type": "number"
        },
        {
            "name": "lastSuccess",
            "baseName": "lastSuccess",
            "type": "number"
        },
        {
            "name": "errorCount",
            "baseName": "errorCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IntegrationSubscriptionStatus.attributeTypeMap;
    }
}

export class Integrations {
    /**
    * A mapping of integration types to their respective API endpoints.
    */
    'links'?: any;
    'items'?: Array<IntegrationSubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "any"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<IntegrationSubscription>"
        }    ];

    static getAttributeTypeMap() {
        return Integrations.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

export class Links {
    'self'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class MAU {
    'links'?: UsageLinks;
    'metadata'?: Array<StreamBySDKLinksMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "UsageLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamBySDKLinksMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return MAU.attributeTypeMap;
    }
}

export class MAUMetadata {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MAUMetadata.attributeTypeMap;
    }
}

export class MAUbyCategory {
    'links'?: StreamBySDKLinks;
    'metadata'?: Array<MAUMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<MAUMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return MAUbyCategory.attributeTypeMap;
    }
}

export class Member {
    'links'?: Links;
    'id'?: Id;
    'role'?: Role;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'verified'?: boolean;
    'pendingInvite'?: boolean;
    'isBeta'?: boolean;
    'customRoles'?: Array<Id>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "_verified",
            "type": "boolean"
        },
        {
            "name": "pendingInvite",
            "baseName": "_pendingInvite",
            "type": "boolean"
        },
        {
            "name": "isBeta",
            "baseName": "isBeta",
            "type": "boolean"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<Id>"
        }    ];

    static getAttributeTypeMap() {
        return Member.attributeTypeMap;
    }
}

export class Members {
    'links'?: Links;
    'items'?: Array<Member>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Member>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Members.attributeTypeMap;
    }
}

export class MembersBody {
    'email': string;
    'firstName'?: string;
    'lastName'?: string;
    'role'?: Role;
    'customRoles'?: Array<string>;
    'inlineRole'?: Array<Statement>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "Role"
        },
        {
            "name": "customRoles",
            "baseName": "customRoles",
            "type": "Array<string>"
        },
        {
            "name": "inlineRole",
            "baseName": "inlineRole",
            "type": "Array<Statement>"
        }    ];

    static getAttributeTypeMap() {
        return MembersBody.attributeTypeMap;
    }
}

export class PatchComment {
    'comment'?: string;
    'patch'?: Array<PatchOperation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "Array<PatchOperation>"
        }    ];

    static getAttributeTypeMap() {
        return PatchComment.attributeTypeMap;
    }
}

export class PatchOperation {
    'op': string;
    'path': string;
    'value': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return PatchOperation.attributeTypeMap;
    }
}

export class Policy {
    'resources'?: Array<string>;
    /**
    * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
    */
    'notResources'?: Array<string>;
    'actions'?: Array<string>;
    /**
    * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
    */
    'notActions'?: Array<string>;
    /**
    * Effect of the policy - allow or deny.
    */
    'effect'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "notResources",
            "baseName": "notResources",
            "type": "Array<string>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<string>"
        },
        {
            "name": "notActions",
            "baseName": "notActions",
            "type": "Array<string>"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Policy.attributeTypeMap;
    }
}

export class Prerequisite {
    'key'?: string;
    'variation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Prerequisite.attributeTypeMap;
    }
}

export class Project {
    'links'?: Links;
    'id'?: Id;
    'key'?: string;
    'name'?: string;
    'includeInSnippetByDefault'?: boolean;
    'environments'?: Array<Environment>;
    /**
    * An array of tags for this project.
    */
    'tags'?: Array<string>;
    'defaultClientSideAvailability'?: ClientSideAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "includeInSnippetByDefault",
            "baseName": "includeInSnippetByDefault",
            "type": "boolean"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "Array<Environment>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "defaultClientSideAvailability",
            "baseName": "defaultClientSideAvailability",
            "type": "ClientSideAvailability"
        }    ];

    static getAttributeTypeMap() {
        return Project.attributeTypeMap;
    }
}

export class ProjectBody {
    'name': string;
    'key': string;
    'includeInSnippetByDefault'?: boolean;
    'tags'?: Array<string>;
    'environments'?: Array<EnvironmentPost>;
    'defaultClientSideAvailability'?: ClientSideAvailability;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "includeInSnippetByDefault",
            "baseName": "includeInSnippetByDefault",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "environments",
            "baseName": "environments",
            "type": "Array<EnvironmentPost>"
        },
        {
            "name": "defaultClientSideAvailability",
            "baseName": "defaultClientSideAvailability",
            "type": "ClientSideAvailability"
        }    ];

    static getAttributeTypeMap() {
        return ProjectBody.attributeTypeMap;
    }
}

export class Projects {
    'links'?: Links;
    'items'?: Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return Projects.attributeTypeMap;
    }
}

export class RelayProxyConfig {
    'id': Id;
    'creator': Member;
    /**
    * A human-friendly name for the relay proxy configuration
    */
    'name': string;
    'policy': Array<Policy>;
    /**
    * Full secret key. Only included if creating or resetting the relay proxy configuration
    */
    'fullKey'?: string;
    /**
    * The last 4 digits of the unique secret key for this relay proxy configuration
    */
    'displayKey': string;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this relay proxy configuration
    */
    'creationDate': number;
    /**
    * A unix epoch time in milliseconds specifying the last time this relay proxy configuration was modified
    */
    'lastModified': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "creator",
            "baseName": "_creator",
            "type": "Member"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        },
        {
            "name": "fullKey",
            "baseName": "fullKey",
            "type": "string"
        },
        {
            "name": "displayKey",
            "baseName": "displayKey",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RelayProxyConfig.attributeTypeMap;
    }
}

export class RelayProxyConfigBody {
    /**
    * A human-friendly name for the relay proxy configuration
    */
    'name'?: string;
    'policy'?: Array<Policy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "Array<Policy>"
        }    ];

    static getAttributeTypeMap() {
        return RelayProxyConfigBody.attributeTypeMap;
    }
}

export class RelayProxyConfigs {
    'items'?: Array<RelayProxyConfig>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<RelayProxyConfig>"
        }    ];

    static getAttributeTypeMap() {
        return RelayProxyConfigs.attributeTypeMap;
    }
}

export class Role {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}

export class Rollout {
    'bucketBy'?: string;
    'variations'?: Array<WeightedVariation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bucketBy",
            "baseName": "bucketBy",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<WeightedVariation>"
        }    ];

    static getAttributeTypeMap() {
        return Rollout.attributeTypeMap;
    }
}

export class Rule {
    'id'?: string;
    'variation'?: number;
    'trackEvents'?: boolean;
    'rollout'?: Rollout;
    'clauses'?: Array<Clause>;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "trackEvents",
            "baseName": "trackEvents",
            "type": "boolean"
        },
        {
            "name": "rollout",
            "baseName": "rollout",
            "type": "Rollout"
        },
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rule.attributeTypeMap;
    }
}

export class ScheduledChangesFeatureFlagConflict {
    /**
    * Feature flag scheduled change id this change will conflict with
    */
    'id'?: string;
    /**
    * Feature flag scheduled change conflict reason
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ScheduledChangesFeatureFlagConflict.attributeTypeMap;
    }
}

export class SemanticPatchInstruction extends Array<SemanticPatchInstructionInner> {

    static discriminator: string | undefined = undefined;

}

export class SemanticPatchInstructionInner {
    /**
    * The name of the modification you would like to perform on a resource.
    */
    'kind'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SemanticPatchInstructionInner.attributeTypeMap;
    }
}

export class SemanticPatchOperation {
    'comment'?: string;
    'instructions': SemanticPatchInstruction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "SemanticPatchInstruction"
        }    ];

    static getAttributeTypeMap() {
        return SemanticPatchOperation.attributeTypeMap;
    }
}

export class Site {
    'href'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Site.attributeTypeMap;
    }
}

export class Statement {
    'resources'?: Array<string>;
    /**
    * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
    */
    'notResources'?: Array<string>;
    'actions'?: Array<string>;
    /**
    * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
    */
    'notActions'?: Array<string>;
    'effect'?: Statement.EffectEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "Array<string>"
        },
        {
            "name": "notResources",
            "baseName": "notResources",
            "type": "Array<string>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<string>"
        },
        {
            "name": "notActions",
            "baseName": "notActions",
            "type": "Array<string>"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "Statement.EffectEnum"
        }    ];

    static getAttributeTypeMap() {
        return Statement.attributeTypeMap;
    }
}

export namespace Statement {
    export enum EffectEnum {
        Allow = <any> 'allow',
        Deny = <any> 'deny'
    }
}
export class Stream {
    'links'?: StreamUsageLinks;
    'metadata'?: Array<StreamUsageMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamUsageLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamUsageMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return Stream.attributeTypeMap;
    }
}

export class StreamBySDK {
    'links'?: StreamBySDKLinks;
    'metadata'?: Array<StreamBySDKLinksMetadata>;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Array<StreamBySDKLinksMetadata>"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDK.attributeTypeMap;
    }
}

export class StreamBySDKLinks {
    'parent'?: Link;
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDKLinks.attributeTypeMap;
    }
}

export class StreamBySDKLinksMetadata {
    'sdk'?: string;
    'version'?: string;
    'source'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamBySDKLinksMetadata.attributeTypeMap;
    }
}

export class StreamLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * Links to endpoints that are in the request path.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return StreamLinks.attributeTypeMap;
    }
}

export class StreamSDKVersion {
    'links'?: StreamBySDKLinks;
    'sdkVersions'?: Array<StreamSDKVersionData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamBySDKLinks"
        },
        {
            "name": "sdkVersions",
            "baseName": "sdkVersions",
            "type": "Array<StreamSDKVersionData>"
        }    ];

    static getAttributeTypeMap() {
        return StreamSDKVersion.attributeTypeMap;
    }
}

export class StreamSDKVersionData {
    /**
    * The language of the sdk
    */
    'sdk'?: string;
    /**
    * The version of the sdk
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamSDKVersionData.attributeTypeMap;
    }
}

export class StreamUsageError {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageError.attributeTypeMap;
    }
}

export class StreamUsageLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * The following links that are in the response.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageLinks.attributeTypeMap;
    }
}

export class StreamUsageMetadata {
    /**
    * The language of the sdk
    */
    'sdk'?: string;
    /**
    * The version of the SDK
    */
    'version'?: string;
    'source'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sdk",
            "baseName": "sdk",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageMetadata.attributeTypeMap;
    }
}

export class StreamUsageSeries {
    /**
    * A key corresponding to a time series data point.
    */
    '_0'?: number;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'time'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_0",
            "baseName": "0",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StreamUsageSeries.attributeTypeMap;
    }
}

export class Streams {
    'links'?: StreamUsageLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "StreamUsageLinks"
        }    ];

    static getAttributeTypeMap() {
        return Streams.attributeTypeMap;
    }
}

export class SubscriptionBody {
    /**
    * A human-readable name for your subscription configuration.
    */
    'name': string;
    'statements'?: Array<Statement>;
    /**
    * Integration-specific configuration fields.
    */
    'config': any;
    /**
    * Whether the integration subscription is active or not.
    */
    'on'?: boolean;
    /**
    * Tags for the integration subscription.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionBody.attributeTypeMap;
    }
}

export class Target {
    'values'?: Array<string>;
    'variation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Target.attributeTypeMap;
    }
}

export class Token {
    'links'?: Links;
    'id'?: Id;
    'ownerId'?: Id;
    'memberId'?: Id;
    'member'?: Member;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this access token.
    */
    'creationDate'?: number;
    /**
    * A unix epoch time in milliseconds specifying the last time this access token was modified.
    */
    'lastModified'?: number;
    /**
    * A unix epoch time in milliseconds specifying the last time this access token was used to authorize access to the LaunchDarkly REST API.
    */
    'lastUsed'?: number;
    /**
    * The last 4 digits of the unique secret key for this access token. If creating or resetting the token, this will be the full token secret.
    */
    'token'?: string;
    /**
    * A human-friendly name for the access token
    */
    'name'?: string;
    /**
    * The name of a built-in role for the token
    */
    'role'?: string;
    /**
    * A list of custom role IDs to use as access limits for the access token
    */
    'customRoleIds'?: Array<string>;
    'inlineRole'?: Array<Statement>;
    /**
    * Whether the token will be a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
    */
    'serviceToken'?: boolean;
    /**
    * The default API version for this token
    */
    'defaultApiVersion'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "ownerId",
            "baseName": "ownerId",
            "type": "Id"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "Id"
        },
        {
            "name": "member",
            "baseName": "_member",
            "type": "Member"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "lastModified",
            "baseName": "lastModified",
            "type": "number"
        },
        {
            "name": "lastUsed",
            "baseName": "lastUsed",
            "type": "number"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "customRoleIds",
            "baseName": "customRoleIds",
            "type": "Array<string>"
        },
        {
            "name": "inlineRole",
            "baseName": "inlineRole",
            "type": "Array<Statement>"
        },
        {
            "name": "serviceToken",
            "baseName": "serviceToken",
            "type": "boolean"
        },
        {
            "name": "defaultApiVersion",
            "baseName": "defaultApiVersion",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Token.attributeTypeMap;
    }
}

export class TokenBody {
    /**
    * A human-friendly name for the access token
    */
    'name'?: string;
    /**
    * The name of a built-in role for the token
    */
    'role'?: string;
    /**
    * A list of custom role IDs to use as access limits for the access token
    */
    'customRoleIds'?: Array<string>;
    'inlineRole'?: Array<Statement>;
    /**
    * Whether the token will be a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
    */
    'serviceToken'?: boolean;
    /**
    * The default API version for this token
    */
    'defaultApiVersion'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "customRoleIds",
            "baseName": "customRoleIds",
            "type": "Array<string>"
        },
        {
            "name": "inlineRole",
            "baseName": "inlineRole",
            "type": "Array<Statement>"
        },
        {
            "name": "serviceToken",
            "baseName": "serviceToken",
            "type": "boolean"
        },
        {
            "name": "defaultApiVersion",
            "baseName": "defaultApiVersion",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TokenBody.attributeTypeMap;
    }
}

export class Tokens {
    'links'?: Links;
    'items'?: Array<Token>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Token>"
        }    ];

    static getAttributeTypeMap() {
        return Tokens.attributeTypeMap;
    }
}

export class UnboundedSegmentTargetChanges {
    /**
    * Users to add to this list of targets
    */
    'add'?: Array<string>;
    /**
    * Users to remove from this list of targets
    */
    'remove'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "add",
            "baseName": "add",
            "type": "Array<string>"
        },
        {
            "name": "remove",
            "baseName": "remove",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UnboundedSegmentTargetChanges.attributeTypeMap;
    }
}

export class UnboundedSegmentTargetsBody {
    'included'?: UnboundedSegmentTargetChanges;
    'excluded'?: UnboundedSegmentTargetChanges;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "included",
            "baseName": "included",
            "type": "UnboundedSegmentTargetChanges"
        },
        {
            "name": "excluded",
            "baseName": "excluded",
            "type": "UnboundedSegmentTargetChanges"
        }    ];

    static getAttributeTypeMap() {
        return UnboundedSegmentTargetsBody.attributeTypeMap;
    }
}

export class Usage {
    'links'?: UsageLinks;
    'series'?: Array<StreamUsageSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "UsageLinks"
        },
        {
            "name": "series",
            "baseName": "series",
            "type": "Array<StreamUsageSeries>"
        }    ];

    static getAttributeTypeMap() {
        return Usage.attributeTypeMap;
    }
}

export class UsageError {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsageError.attributeTypeMap;
    }
}

export class UsageLinks {
    'parent'?: Link;
    'self'?: Link;
    /**
    * The following links that are in the response.
    */
    'subseries'?: Array<Link>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "subseries",
            "baseName": "subseries",
            "type": "Array<Link>"
        }    ];

    static getAttributeTypeMap() {
        return UsageLinks.attributeTypeMap;
    }
}

export class User {
    'key'?: string;
    'secondary'?: string;
    'ip'?: string;
    'country'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'avatar'?: string;
    'name'?: string;
    'anonymous'?: boolean;
    'custom'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "secondary",
            "baseName": "secondary",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "anonymous",
            "baseName": "anonymous",
            "type": "boolean"
        },
        {
            "name": "custom",
            "baseName": "custom",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserFlagSetting {
    'links'?: Links;
    /**
    * The most important attribute in the response. The _value is the current setting for the user. For a boolean feature toggle, this will be true, false, or null if there is no defined fallthrough value.
    */
    'value'?: boolean;
    /**
    * The setting attribute indicates whether you've explicitly targeted this user to receive a particular variation. For example, if you have explicitly turned off a feature toggle for a user, setting will be false. A setting of null means that you haven't assigned that user to a specific variation.
    */
    'setting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "value",
            "baseName": "_value",
            "type": "boolean"
        },
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSetting.attributeTypeMap;
    }
}

export class UserFlagSettings {
    'links'?: Links;
    'items'?: { [key: string]: UserFlagSetting; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "{ [key: string]: UserFlagSetting; }"
        }    ];

    static getAttributeTypeMap() {
        return UserFlagSettings.attributeTypeMap;
    }
}

export class UserRecord {
    'lastPing'?: string;
    'environmentId'?: string;
    'ownerId'?: Id;
    'user'?: User;
    'avatar'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastPing",
            "baseName": "lastPing",
            "type": "string"
        },
        {
            "name": "environmentId",
            "baseName": "environmentId",
            "type": "string"
        },
        {
            "name": "ownerId",
            "baseName": "ownerId",
            "type": "Id"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserRecord.attributeTypeMap;
    }
}

export class UserSegment {
    /**
    * Unique identifier for the user segment.
    */
    'key': string;
    /**
    * Name of the user segment.
    */
    'name': string;
    /**
    * Description of the user segment.
    */
    'description'?: string;
    /**
    * An array of tags for this user segment.
    */
    'tags'?: Array<string>;
    /**
    * A unix epoch time in milliseconds specifying the creation time of this flag.
    */
    'creationDate': number;
    /**
    * An array of user keys that are included in this segment.
    */
    'included'?: Array<string>;
    /**
    * An array of user keys that should not be included in this segment, unless they are also listed in \"included\".
    */
    'excluded'?: Array<string>;
    /**
    * An array of rules that can cause a user to be included in this segment.
    */
    'rules'?: Array<UserSegmentRule>;
    /**
    * Controls whether this segment can support unlimited numbers of users. Requires the beta API and additional setup. Include/exclude lists in this payload are not used in unbounded segments.
    */
    'unbounded'?: boolean;
    'version'?: number;
    'links'?: Links;
    'flags'?: Array<FlagListItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "creationDate",
            "baseName": "creationDate",
            "type": "number"
        },
        {
            "name": "included",
            "baseName": "included",
            "type": "Array<string>"
        },
        {
            "name": "excluded",
            "baseName": "excluded",
            "type": "Array<string>"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<UserSegmentRule>"
        },
        {
            "name": "unbounded",
            "baseName": "unbounded",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "flags",
            "baseName": "_flags",
            "type": "Array<FlagListItem>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegment.attributeTypeMap;
    }
}

export class UserSegmentBody {
    /**
    * A human-friendly name for the user segment.
    */
    'name': string;
    /**
    * A unique key that will be used to reference the user segment in feature flags.
    */
    'key': string;
    /**
    * A description for the user segment.
    */
    'description'?: string;
    /**
    * Controls whether this segment can support unlimited numbers of users. Requires the beta API and additional setup. Include/exclude lists in this payload are not used in unbounded segments.
    */
    'unbounded'?: boolean;
    /**
    * Tags for the user segment.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "unbounded",
            "baseName": "unbounded",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentBody.attributeTypeMap;
    }
}

export class UserSegmentRule {
    'clauses'?: Array<Clause>;
    'weight'?: number;
    'bucketBy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clauses",
            "baseName": "clauses",
            "type": "Array<Clause>"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        },
        {
            "name": "bucketBy",
            "baseName": "bucketBy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSegmentRule.attributeTypeMap;
    }
}

export class UserSegments {
    'links'?: Links;
    'items'?: Array<UserSegment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserSegment>"
        }    ];

    static getAttributeTypeMap() {
        return UserSegments.attributeTypeMap;
    }
}

export class UserSettingsBody {
    /**
    * The variation value to set for the user. Must match the variation type of the flag. 
    */
    'setting'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "setting",
            "baseName": "setting",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserSettingsBody.attributeTypeMap;
    }
}

export class UserTargetingExpirationForFlag {
    /**
    * Unix epoch time in milliseconds specifying the expiration date
    */
    'expirationDate'?: number;
    /**
    * the ID of the variation that the user is targeted on a flag
    */
    'variationId'?: string;
    /**
    * Unique identifier for the user
    */
    'userKey'?: string;
    'id'?: string;
    'resourceId'?: UserTargetingExpirationResourceIdForFlag;
    'links'?: Links;
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "number"
        },
        {
            "name": "variationId",
            "baseName": "variationId",
            "type": "string"
        },
        {
            "name": "userKey",
            "baseName": "userKey",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "resourceId",
            "baseName": "_resourceId",
            "type": "UserTargetingExpirationResourceIdForFlag"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserTargetingExpirationForFlag.attributeTypeMap;
    }
}

export class UserTargetingExpirationForFlags {
    'links'?: Links;
    'items'?: Array<UserTargetingExpirationForFlag>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserTargetingExpirationForFlag>"
        }    ];

    static getAttributeTypeMap() {
        return UserTargetingExpirationForFlags.attributeTypeMap;
    }
}

export class UserTargetingExpirationForSegment {
    /**
    * Unix epoch time in milliseconds specifying the expiration date
    */
    'expirationDate'?: number;
    /**
    * either the included or excluded variation that the user is targeted on a segment
    */
    'targetType'?: string;
    /**
    * Unique identifier for the user
    */
    'userKey'?: string;
    'id'?: string;
    'resourceId'?: UserTargetingExpirationResourceIdForFlag;
    'links'?: Links;
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "number"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "string"
        },
        {
            "name": "userKey",
            "baseName": "userKey",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "resourceId",
            "baseName": "_resourceId",
            "type": "UserTargetingExpirationResourceIdForFlag"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "version",
            "baseName": "_version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserTargetingExpirationForSegment.attributeTypeMap;
    }
}

export class UserTargetingExpirationOnFlagsForUser {
    'links'?: Links;
    'items'?: Array<UserTargetingExpirationForFlag>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserTargetingExpirationForFlag>"
        }    ];

    static getAttributeTypeMap() {
        return UserTargetingExpirationOnFlagsForUser.attributeTypeMap;
    }
}

export class UserTargetingExpirationResourceIdForFlag {
    'kind'?: string;
    'projectKey'?: string;
    'environmentKey'?: string;
    'flagKey'?: string;
    'key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "projectKey",
            "baseName": "projectKey",
            "type": "string"
        },
        {
            "name": "environmentKey",
            "baseName": "environmentKey",
            "type": "string"
        },
        {
            "name": "flagKey",
            "baseName": "flagKey",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserTargetingExpirationResourceIdForFlag.attributeTypeMap;
    }
}

export class Users {
    'links'?: Links;
    'totalCount'?: number;
    'items'?: Array<UserRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<UserRecord>"
        }    ];

    static getAttributeTypeMap() {
        return Users.attributeTypeMap;
    }
}

export class Variation {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'value': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Variation.attributeTypeMap;
    }
}

export class Webhook {
    'links'?: Links;
    'id'?: Id;
    /**
    * The URL of the remote webhook.
    */
    'url'?: string;
    /**
    * If defined, the webhooks post request will include a X-LD-Signature header whose value will contain an HMAC SHA256 hex digest of the webhook payload, using the secret as the key.
    */
    'secret'?: string;
    /**
    * Whether this webhook is enabled or not.
    */
    'on'?: boolean;
    /**
    * The name of the webhook.
    */
    'name'?: string;
    'statements'?: Array<Statement>;
    /**
    * Tags assigned to this webhook.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "_id",
            "type": "Id"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Webhook.attributeTypeMap;
    }
}

export class WebhookBody {
    /**
    * The URL of the remote webhook.
    */
    'url': string;
    /**
    * If sign is true, and the secret attribute is omitted, LaunchDarkly will automatically generate a secret for you.
    */
    'secret'?: string;
    /**
    * If sign is false, the webhook will not include a signature header, and the secret can be omitted.
    */
    'sign': boolean;
    /**
    * Whether this webhook is enabled or not.
    */
    'on': boolean;
    /**
    * The name of the webhook.
    */
    'name'?: string;
    'statements'?: Array<Statement>;
    /**
    * Tags for the webhook.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "sign",
            "baseName": "sign",
            "type": "boolean"
        },
        {
            "name": "on",
            "baseName": "on",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "statements",
            "baseName": "statements",
            "type": "Array<Statement>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return WebhookBody.attributeTypeMap;
    }
}

export class Webhooks {
    'links'?: Links;
    'items'?: Array<Webhook>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Webhook>"
        }    ];

    static getAttributeTypeMap() {
        return Webhooks.attributeTypeMap;
    }
}

export class WeightedVariation {
    'variation'?: number;
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variation",
            "baseName": "variation",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WeightedVariation.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Destination.KindEnum": Destination.KindEnum,
        "DestinationBody.KindEnum": DestinationBody.KindEnum,
        "EnvironmentApprovalSettings.ServiceKindEnum": EnvironmentApprovalSettings.ServiceKindEnum,
        "FeatureFlagApprovalRequest.StatusEnum": FeatureFlagApprovalRequest.StatusEnum,
        "FeatureFlagApprovalRequestReviewConfigBody.KindEnum": FeatureFlagApprovalRequestReviewConfigBody.KindEnum,
        "FeatureFlagStatus.NameEnum": FeatureFlagStatus.NameEnum,
        "FeatureFlagStatusForQueriedEnvironment.NameEnum": FeatureFlagStatusForQueriedEnvironment.NameEnum,
        "Statement.EffectEnum": Statement.EffectEnum,
}

let typeMap: {[index: string]: any} = {
    "AuditLogEntries": AuditLogEntries,
    "AuditLogEntry": AuditLogEntry,
    "AuditLogEntryTarget": AuditLogEntryTarget,
    "Clause": Clause,
    "ClientSideAvailability": ClientSideAvailability,
    "CopyActions": CopyActions,
    "CustomProperty": CustomProperty,
    "CustomPropertyValues": CustomPropertyValues,
    "CustomRole": CustomRole,
    "CustomRoleBody": CustomRoleBody,
    "CustomRoles": CustomRoles,
    "Defaults": Defaults,
    "Destination": Destination,
    "DestinationAmazonKinesis": DestinationAmazonKinesis,
    "DestinationBody": DestinationBody,
    "DestinationGooglePubSub": DestinationGooglePubSub,
    "DestinationMParticle": DestinationMParticle,
    "DestinationSegment": DestinationSegment,
    "Destinations": Destinations,
    "Environment": Environment,
    "EnvironmentApprovalSettings": EnvironmentApprovalSettings,
    "EnvironmentPost": EnvironmentPost,
    "EvaluationUsageError": EvaluationUsageError,
    "Events": Events,
    "Fallthrough": Fallthrough,
    "FeatureFlag": FeatureFlag,
    "FeatureFlagApprovalRequest": FeatureFlagApprovalRequest,
    "FeatureFlagApprovalRequestApplyConfigBody": FeatureFlagApprovalRequestApplyConfigBody,
    "FeatureFlagApprovalRequestConfigBody": FeatureFlagApprovalRequestConfigBody,
    "FeatureFlagApprovalRequestReview": FeatureFlagApprovalRequestReview,
    "FeatureFlagApprovalRequestReviewConfigBody": FeatureFlagApprovalRequestReviewConfigBody,
    "FeatureFlagApprovalRequestReviewStatus": FeatureFlagApprovalRequestReviewStatus,
    "FeatureFlagApprovalRequests": FeatureFlagApprovalRequests,
    "FeatureFlagBody": FeatureFlagBody,
    "FeatureFlagConfig": FeatureFlagConfig,
    "FeatureFlagCopyBody": FeatureFlagCopyBody,
    "FeatureFlagCopyObject": FeatureFlagCopyObject,
    "FeatureFlagScheduledChange": FeatureFlagScheduledChange,
    "FeatureFlagScheduledChanges": FeatureFlagScheduledChanges,
    "FeatureFlagScheduledChangesConflicts": FeatureFlagScheduledChangesConflicts,
    "FeatureFlagScheduledChangesConflictsInstructions": FeatureFlagScheduledChangesConflictsInstructions,
    "FeatureFlagStatus": FeatureFlagStatus,
    "FeatureFlagStatusAcrossEnvironments": FeatureFlagStatusAcrossEnvironments,
    "FeatureFlagStatusForQueriedEnvironment": FeatureFlagStatusForQueriedEnvironment,
    "FeatureFlagStatuses": FeatureFlagStatuses,
    "FeatureFlags": FeatureFlags,
    "FlagListItem": FlagListItem,
    "HierarchicalLinks": HierarchicalLinks,
    "Id": Id,
    "Integration": Integration,
    "IntegrationLinks": IntegrationLinks,
    "IntegrationSubscription": IntegrationSubscription,
    "IntegrationSubscriptionStatus": IntegrationSubscriptionStatus,
    "Integrations": Integrations,
    "Link": Link,
    "Links": Links,
    "MAU": MAU,
    "MAUMetadata": MAUMetadata,
    "MAUbyCategory": MAUbyCategory,
    "Member": Member,
    "Members": Members,
    "MembersBody": MembersBody,
    "PatchComment": PatchComment,
    "PatchOperation": PatchOperation,
    "Policy": Policy,
    "Prerequisite": Prerequisite,
    "Project": Project,
    "ProjectBody": ProjectBody,
    "Projects": Projects,
    "RelayProxyConfig": RelayProxyConfig,
    "RelayProxyConfigBody": RelayProxyConfigBody,
    "RelayProxyConfigs": RelayProxyConfigs,
    "Role": Role,
    "Rollout": Rollout,
    "Rule": Rule,
    "ScheduledChangesFeatureFlagConflict": ScheduledChangesFeatureFlagConflict,
    "SemanticPatchInstruction": SemanticPatchInstruction,
    "SemanticPatchInstructionInner": SemanticPatchInstructionInner,
    "SemanticPatchOperation": SemanticPatchOperation,
    "Site": Site,
    "Statement": Statement,
    "Stream": Stream,
    "StreamBySDK": StreamBySDK,
    "StreamBySDKLinks": StreamBySDKLinks,
    "StreamBySDKLinksMetadata": StreamBySDKLinksMetadata,
    "StreamLinks": StreamLinks,
    "StreamSDKVersion": StreamSDKVersion,
    "StreamSDKVersionData": StreamSDKVersionData,
    "StreamUsageError": StreamUsageError,
    "StreamUsageLinks": StreamUsageLinks,
    "StreamUsageMetadata": StreamUsageMetadata,
    "StreamUsageSeries": StreamUsageSeries,
    "Streams": Streams,
    "SubscriptionBody": SubscriptionBody,
    "Target": Target,
    "Token": Token,
    "TokenBody": TokenBody,
    "Tokens": Tokens,
    "UnboundedSegmentTargetChanges": UnboundedSegmentTargetChanges,
    "UnboundedSegmentTargetsBody": UnboundedSegmentTargetsBody,
    "Usage": Usage,
    "UsageError": UsageError,
    "UsageLinks": UsageLinks,
    "User": User,
    "UserFlagSetting": UserFlagSetting,
    "UserFlagSettings": UserFlagSettings,
    "UserRecord": UserRecord,
    "UserSegment": UserSegment,
    "UserSegmentBody": UserSegmentBody,
    "UserSegmentRule": UserSegmentRule,
    "UserSegments": UserSegments,
    "UserSettingsBody": UserSettingsBody,
    "UserTargetingExpirationForFlag": UserTargetingExpirationForFlag,
    "UserTargetingExpirationForFlags": UserTargetingExpirationForFlags,
    "UserTargetingExpirationForSegment": UserTargetingExpirationForSegment,
    "UserTargetingExpirationOnFlagsForUser": UserTargetingExpirationOnFlagsForUser,
    "UserTargetingExpirationResourceIdForFlag": UserTargetingExpirationResourceIdForFlag,
    "Users": Users,
    "Variation": Variation,
    "Webhook": Webhook,
    "WebhookBody": WebhookBody,
    "Webhooks": Webhooks,
    "WeightedVariation": WeightedVariation,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccessTokensApiApiKeys {
    Token,
}

export class AccessTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessTokensApiApiKeys, value: string) {
        (this.authentications as any)[AccessTokensApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an access token by ID.
     * @param tokenId The access token ID.
     * @param {*} [options] Override http request options.
     */
    public deleteToken (tokenId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tokens/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling deleteToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single access token by ID.
     * @param tokenId The access token ID.
     * @param {*} [options] Override http request options.
     */
    public getToken (tokenId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/tokens/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling getToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of tokens in the account.
     * @param showAll If set to true, and the authentication access token has the \&quot;Admin\&quot; role, personal access tokens for all members will be retrieved.
     * @param {*} [options] Override http request options.
     */
    public getTokens (showAll?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Tokens;  }> {
        const localVarPath = this.basePath + '/tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (showAll !== undefined) {
            localVarQueryParameters['showAll'] = ObjectSerializer.serialize(showAll, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tokens;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tokens");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify an access token by ID.
     * @param tokenId The access token ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchToken (tokenId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/tokens/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling patchToken.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new token.
     * @param tokenBody Create a new access token.
     * @param {*} [options] Override http request options.
     */
    public postToken (tokenBody: TokenBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenBody' is not null or undefined
        if (tokenBody === null || tokenBody === undefined) {
            throw new Error('Required parameter tokenBody was null or undefined when calling postToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tokenBody, "TokenBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset an access token's secret key with an optional expiry time for the old key.
     * @param tokenId The access token ID.
     * @param expiry An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
     * @param {*} [options] Override http request options.
     */
    public resetToken (tokenId: string, expiry?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/tokens/{tokenId}/reset'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling resetToken.');
        }

        if (expiry !== undefined) {
            localVarQueryParameters['expiry'] = ObjectSerializer.serialize(expiry, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuditLogApiApiKeys {
    Token,
}

export class AuditLogApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuditLogApiApiKeys, value: string) {
        (this.authentications as any)[AuditLogApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
     * @param before A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
     * @param q Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change.
     * @param limit A limit on the number of audit log entries to be returned, between 1 and 20.
     * @param spec A resource specifier, allowing you to filter audit log listings by resource.
     * @param {*} [options] Override http request options.
     */
    public getAuditLogEntries (before?: number, after?: number, q?: string, limit?: number, spec?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }> {
        const localVarPath = this.basePath + '/auditlog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (spec !== undefined) {
            localVarQueryParameters['spec'] = ObjectSerializer.serialize(spec, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public getAuditLogEntry (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }> {
        const localVarPath = this.basePath + '/auditlog/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getAuditLogEntry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditLogEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuditLogEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomRolesApiApiKeys {
    Token,
}

export class CustomRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomRolesApiApiKeys, value: string) {
        (this.authentications as any)[CustomRolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a custom role by key.
     * @param customRoleKey The custom role key.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomRole (customRoleKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling deleteCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get one custom role by key.
     * @param customRoleKey The custom role key.
     * @param {*} [options] Override http request options.
     */
    public getCustomRole (customRoleKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling getCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a complete list of custom roles.
     * @param {*} [options] Override http request options.
     */
    public getCustomRoles (options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRoles;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRoles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRoles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a custom role by key.
     * @param customRoleKey The custom role key.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchCustomRole (customRoleKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles/{customRoleKey}'
            .replace('{' + 'customRoleKey' + '}', encodeURIComponent(String(customRoleKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleKey' is not null or undefined
        if (customRoleKey === null || customRoleKey === undefined) {
            throw new Error('Required parameter customRoleKey was null or undefined when calling patchCustomRole.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new custom role.
     * @param customRoleBody New role or roles to create.
     * @param {*} [options] Override http request options.
     */
    public postCustomRole (customRoleBody: CustomRoleBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomRole;  }> {
        const localVarPath = this.basePath + '/roles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRoleBody' is not null or undefined
        if (customRoleBody === null || customRoleBody === undefined) {
            throw new Error('Required parameter customRoleBody was null or undefined when calling postCustomRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customRoleBody, "CustomRoleBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomRole;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRole");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerMetricsApiApiKeys {
    Token,
}

export class CustomerMetricsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerMetricsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerMetricsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get events usage by event id and the feature flag key.
     * @param envId The environment id for the flag evaluations in question.
     * @param flagKey The key of the flag we want metrics for.
     * @param {*} [options] Override http request options.
     */
    public getEvaluations (envId: string, flagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/evaluations/{envId}/{flagKey}'
            .replace('{' + 'envId' + '}', encodeURIComponent(String(envId)))
            .replace('{' + 'flagKey' + '}', encodeURIComponent(String(flagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'envId' is not null or undefined
        if (envId === null || envId === undefined) {
            throw new Error('Required parameter envId was null or undefined when calling getEvaluations.');
        }

        // verify required parameter 'flagKey' is not null or undefined
        if (flagKey === null || flagKey === undefined) {
            throw new Error('Required parameter flagKey was null or undefined when calling getEvaluations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events usage by event type.
     * @param type The type of event we would like to track.
     * @param {*} [options] Override http request options.
     */
    public getEvent (type: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/events/{type}'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get events usage endpoints.
     * @param {*} [options] Override http request options.
     */
    public getEvents (options: any = {}) : Promise<{ response: http.ClientResponse; body: Events;  }> {
        const localVarPath = this.basePath + '/usage/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get monthly active user data.
     * @param {*} [options] Override http request options.
     */
    public getMAU (options: any = {}) : Promise<{ response: http.ClientResponse; body: MAU;  }> {
        const localVarPath = this.basePath + '/usage/mau';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MAU;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MAU");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get monthly active user data by category.
     * @param {*} [options] Override http request options.
     */
    public getMAUByCategory (options: any = {}) : Promise<{ response: http.ClientResponse; body: MAUbyCategory;  }> {
        const localVarPath = this.basePath + '/usage/mau/bycategory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MAUbyCategory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MAUbyCategory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream endpoint and return timeseries data.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStream (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Stream;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStream.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Stream;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Stream");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream timeseries data by source show sdk version metadata.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStreamBySDK (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamBySDK;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}/bysdkversion'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStreamBySDK.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamBySDK;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamBySDK");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a stream timeseries data by source and show all sdk version associated.
     * @param source The source of where the stream comes from.
     * @param {*} [options] Override http request options.
     */
    public getStreamSDKVersion (source: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }> {
        const localVarPath = this.basePath + '/usage/streams/{source}/sdkversions'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getStreamSDKVersion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSDKVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSDKVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all streams.
     * @param {*} [options] Override http request options.
     */
    public getStreams (options: any = {}) : Promise<{ response: http.ClientResponse; body: Streams;  }> {
        const localVarPath = this.basePath + '/usage/streams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Streams;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Streams");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns of the usage endpoints available.
     * @param {*} [options] Override http request options.
     */
    public getUsage (options: any = {}) : Promise<{ response: http.ClientResponse; body: Usage;  }> {
        const localVarPath = this.basePath + '/usage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Usage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Usage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataExportDestinationsApiApiKeys {
    Token,
}

export class DataExportDestinationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DataExportDestinationsApiApiKeys, value: string) {
        (this.authentications as any)[DataExportDestinationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a single data export destination by ID
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param {*} [options] Override http request options.
     */
    public deleteDestination (projectKey: string, environmentKey: string, destinationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling deleteDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single data export destination by ID
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param {*} [options] Override http request options.
     */
    public getDestination (projectKey: string, environmentKey: string, destinationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling getDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all data export destinations.
     * @param {*} [options] Override http request options.
     */
    public getDestinations (options: any = {}) : Promise<{ response: http.ClientResponse; body: Destinations;  }> {
        const localVarPath = this.basePath + '/destinations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destinations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destinations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a data export destination.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationId The data export destination ID.
     * @param patchOnly Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchDestination (projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}/{destinationId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'destinationId' + '}', encodeURIComponent(String(destinationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling patchDestination.');
        }

        // verify required parameter 'patchOnly' is not null or undefined
        if (patchOnly === null || patchOnly === undefined) {
            throw new Error('Required parameter patchOnly was null or undefined when calling patchDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchOnly, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new data export destination
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param destinationBody Create a new data export destination.
     * @param {*} [options] Override http request options.
     */
    public postDestination (projectKey: string, environmentKey: string, destinationBody: DestinationBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Destination;  }> {
        const localVarPath = this.basePath + '/destinations/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postDestination.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postDestination.');
        }

        // verify required parameter 'destinationBody' is not null or undefined
        if (destinationBody === null || destinationBody === undefined) {
            throw new Error('Required parameter destinationBody was null or undefined when calling postDestination.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(destinationBody, "DestinationBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Destination;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Destination");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EnvironmentsApiApiKeys {
    Token,
}

export class EnvironmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EnvironmentsApiApiKeys, value: string) {
        (this.authentications as any)[EnvironmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an environment in a specific project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public deleteEnvironment (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an environment given a project and key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getEnvironment (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify an environment by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchEnvironment (projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchEnvironment.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new environment in a specified project with a given name, key, and swatch color.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentBody New environment.
     * @param {*} [options] Override http request options.
     */
    public postEnvironment (projectKey: string, environmentBody: EnvironmentPost, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postEnvironment.');
        }

        // verify required parameter 'environmentBody' is not null or undefined
        if (environmentBody === null || environmentBody === undefined) {
            throw new Error('Required parameter environmentBody was null or undefined when calling postEnvironment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(environmentBody, "EnvironmentPost")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset an environment's mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param expiry The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version.
     * @param {*} [options] Override http request options.
     */
    public resetEnvironmentMobileKey (projectKey: string, environmentKey: string, expiry?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}/mobileKey'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling resetEnvironmentMobileKey.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling resetEnvironmentMobileKey.');
        }

        if (expiry !== undefined) {
            localVarQueryParameters['expiry'] = ObjectSerializer.serialize(expiry, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset an environment's SDK key with an optional expiry time for the old key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param expiry An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately.
     * @param {*} [options] Override http request options.
     */
    public resetEnvironmentSDKKey (projectKey: string, environmentKey: string, expiry?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Environment;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/environments/{environmentKey}/apiKey'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling resetEnvironmentSDKKey.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling resetEnvironmentSDKKey.');
        }

        if (expiry !== undefined) {
            localVarQueryParameters['expiry'] = ObjectSerializer.serialize(expiry, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Environment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeatureFlagsApiApiKeys {
    Token,
}

export class FeatureFlagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeatureFlagsApiApiKeys, value: string) {
        (this.authentications as any)[FeatureFlagsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param featureFlagCopyBody Copy feature flag configurations between environments.
     * @param {*} [options] Override http request options.
     */
    public copyFeatureFlag (projectKey: string, featureFlagKey: string, featureFlagCopyBody: FeatureFlagCopyBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}/copy'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling copyFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling copyFeatureFlag.');
        }

        // verify required parameter 'featureFlagCopyBody' is not null or undefined
        if (featureFlagCopyBody === null || featureFlagCopyBody === undefined) {
            throw new Error('Required parameter featureFlagCopyBody was null or undefined when calling copyFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagCopyBody, "FeatureFlagCopyBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public deleteFeatureFlag (projectKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling deleteFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an approval request for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param featureFlagApprovalRequestId The feature flag approval request ID
     * @param featureFlagApprovalRequestConfigBody Create a new feature flag approval request
     * @param {*} [options] Override http request options.
     */
    public deleteFeatureFlagApprovalRequest (projectKey: string, environmentKey: string, featureFlagKey: string, featureFlagApprovalRequestId: string, featureFlagApprovalRequestConfigBody?: FeatureFlagApprovalRequestConfigBody, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{featureFlagApprovalRequestId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'featureFlagApprovalRequestId' + '}', encodeURIComponent(String(featureFlagApprovalRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling deleteFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestId' is not null or undefined
        if (featureFlagApprovalRequestId === null || featureFlagApprovalRequestId === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestId was null or undefined when calling deleteFeatureFlagApprovalRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagApprovalRequestConfigBody, "FeatureFlagApprovalRequestConfigBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get expiring user targets for feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getExpiringUserTargets (projectKey: string, environmentKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForFlags;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getExpiringUserTargets.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getExpiringUserTargets.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getExpiringUserTargets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForFlags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationForFlags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single feature flag by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlag (projectKey: string, featureFlagKey: string, env?: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlag.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single approval request for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagApprovalRequestId The feature flag approval request ID
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagApprovalRequest (projectKey: string, featureFlagKey: string, environmentKey: string, featureFlagApprovalRequestId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{featureFlagApprovalRequestId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagApprovalRequestId' + '}', encodeURIComponent(String(featureFlagApprovalRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestId' is not null or undefined
        if (featureFlagApprovalRequestId === null || featureFlagApprovalRequestId === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestId was null or undefined when calling getFeatureFlagApprovalRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagApprovalRequests");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all approval requests for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagApprovalRequests (projectKey: string, featureFlagKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagApprovalRequests.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagApprovalRequests.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagApprovalRequests.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagApprovalRequests");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status for a particular feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatus (projectKey: string, environmentKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatus.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status for a particular feature flag across environments
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatusAcrossEnvironments (projectKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatusAcrossEnvironments;  }> {
        const localVarPath = this.basePath + '/flag-status/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatusAcrossEnvironments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatusAcrossEnvironments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlagStatuses (projectKey: string, environmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }> {
        const localVarPath = this.basePath + '/flag-statuses/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlagStatuses.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getFeatureFlagStatuses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagStatuses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagStatuses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all features in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
     * @param archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
     * @param limit The number of objects to return. Defaults to -1, which returns everything.
     * @param offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param filter A comma-separated list of filters. Each filter is of the form field:value.
     * @param sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request options.
     */
    public getFeatureFlags (projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, offset?: number, filter?: string, sort?: string, tag?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlags;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getFeatureFlags.');
        }

        if (env !== undefined) {
            localVarQueryParameters['env'] = ObjectSerializer.serialize(env, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "boolean");
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update, add, or delete expiring user targets on feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchExpiringUserTargets (projectKey: string, environmentKey: string, featureFlagKey: string, semanticPatchWithComment: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForFlags;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchExpiringUserTargets.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchExpiringUserTargets.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling patchExpiringUserTargets.');
        }

        // verify required parameter 'semanticPatchWithComment' is not null or undefined
        if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
            throw new Error('Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(semanticPatchWithComment, "any")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForFlags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationForFlags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a feature.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param patchComment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchFeatureFlag (projectKey: string, featureFlagKey: string, patchComment: PatchComment, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling patchFeatureFlag.');
        }

        // verify required parameter 'patchComment' is not null or undefined
        if (patchComment === null || patchComment === undefined) {
            throw new Error('Required parameter patchComment was null or undefined when calling patchFeatureFlag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchComment, "PatchComment")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Apply approval request for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagApprovalRequestId The feature flag approval request ID
     * @param featureFlagApprovalRequestApplyConfigBody Apply a new feature flag approval request
     * @param {*} [options] Override http request options.
     */
    public postApplyFeatureFlagApprovalRequest (projectKey: string, featureFlagKey: string, environmentKey: string, featureFlagApprovalRequestId: string, featureFlagApprovalRequestApplyConfigBody: FeatureFlagApprovalRequestApplyConfigBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{featureFlagApprovalRequestId}/apply'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagApprovalRequestId' + '}', encodeURIComponent(String(featureFlagApprovalRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postApplyFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling postApplyFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postApplyFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestId' is not null or undefined
        if (featureFlagApprovalRequestId === null || featureFlagApprovalRequestId === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestId was null or undefined when calling postApplyFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestApplyConfigBody' is not null or undefined
        if (featureFlagApprovalRequestApplyConfigBody === null || featureFlagApprovalRequestApplyConfigBody === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestApplyConfigBody was null or undefined when calling postApplyFeatureFlagApprovalRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagApprovalRequestApplyConfigBody, "FeatureFlagApprovalRequestApplyConfigBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagApprovalRequests");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new feature flag.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagBody Create a new feature flag.
     * @param clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
     * @param {*} [options] Override http request options.
     */
    public postFeatureFlag (projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlag;  }> {
        const localVarPath = this.basePath + '/flags/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postFeatureFlag.');
        }

        // verify required parameter 'featureFlagBody' is not null or undefined
        if (featureFlagBody === null || featureFlagBody === undefined) {
            throw new Error('Required parameter featureFlagBody was null or undefined when calling postFeatureFlag.');
        }

        if (clone !== undefined) {
            localVarQueryParameters['clone'] = ObjectSerializer.serialize(clone, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagBody, "FeatureFlagBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an approval request for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagApprovalRequestId The feature flag approval request ID
     * @param featureFlagApprovalRequestConfigBody Create a new feature flag approval request
     * @param {*} [options] Override http request options.
     */
    public postFeatureFlagApprovalRequest (projectKey: string, featureFlagKey: string, environmentKey: string, featureFlagApprovalRequestId: string, featureFlagApprovalRequestConfigBody?: FeatureFlagApprovalRequestConfigBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequest;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{featureFlagApprovalRequestId}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagApprovalRequestId' + '}', encodeURIComponent(String(featureFlagApprovalRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling postFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestId' is not null or undefined
        if (featureFlagApprovalRequestId === null || featureFlagApprovalRequestId === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestId was null or undefined when calling postFeatureFlagApprovalRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagApprovalRequestConfigBody, "FeatureFlagApprovalRequestConfigBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagApprovalRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Review approval request for a feature flag
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param featureFlagApprovalRequestId The feature flag approval request ID
     * @param featureFlagApprovalRequestReviewConfigBody Review a feature flag approval request
     * @param {*} [options] Override http request options.
     */
    public postReviewFeatureFlagApprovalRequest (projectKey: string, featureFlagKey: string, environmentKey: string, featureFlagApprovalRequestId: string, featureFlagApprovalRequestReviewConfigBody: FeatureFlagApprovalRequestReviewConfigBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{featureFlagApprovalRequestId}/review'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'featureFlagApprovalRequestId' + '}', encodeURIComponent(String(featureFlagApprovalRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postReviewFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling postReviewFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postReviewFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestId' is not null or undefined
        if (featureFlagApprovalRequestId === null || featureFlagApprovalRequestId === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestId was null or undefined when calling postReviewFeatureFlagApprovalRequest.');
        }

        // verify required parameter 'featureFlagApprovalRequestReviewConfigBody' is not null or undefined
        if (featureFlagApprovalRequestReviewConfigBody === null || featureFlagApprovalRequestReviewConfigBody === undefined) {
            throw new Error('Required parameter featureFlagApprovalRequestReviewConfigBody was null or undefined when calling postReviewFeatureFlagApprovalRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(featureFlagApprovalRequestReviewConfigBody, "FeatureFlagApprovalRequestReviewConfigBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FeatureFlagApprovalRequests;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FeatureFlagApprovalRequests");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IntegrationsApiApiKeys {
    Token,
}

export class IntegrationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IntegrationsApiApiKeys, value: string) {
        (this.authentications as any)[IntegrationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an integration subscription by ID.
     * @param integrationKey The key used to specify the integration kind.
     * @param integrationId The integration ID.
     * @param {*} [options] Override http request options.
     */
    public deleteIntegrationSubscription (integrationKey: string, integrationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/integrations/{integrationKey}/{integrationId}'
            .replace('{' + 'integrationKey' + '}', encodeURIComponent(String(integrationKey)))
            .replace('{' + 'integrationId' + '}', encodeURIComponent(String(integrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationKey' is not null or undefined
        if (integrationKey === null || integrationKey === undefined) {
            throw new Error('Required parameter integrationKey was null or undefined when calling deleteIntegrationSubscription.');
        }

        // verify required parameter 'integrationId' is not null or undefined
        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling deleteIntegrationSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single integration subscription by ID.
     * @param integrationKey The key used to specify the integration kind.
     * @param integrationId The integration ID.
     * @param {*} [options] Override http request options.
     */
    public getIntegrationSubscription (integrationKey: string, integrationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }> {
        const localVarPath = this.basePath + '/integrations/{integrationKey}/{integrationId}'
            .replace('{' + 'integrationKey' + '}', encodeURIComponent(String(integrationKey)))
            .replace('{' + 'integrationId' + '}', encodeURIComponent(String(integrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationKey' is not null or undefined
        if (integrationKey === null || integrationKey === undefined) {
            throw new Error('Required parameter integrationKey was null or undefined when calling getIntegrationSubscription.');
        }

        // verify required parameter 'integrationId' is not null or undefined
        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling getIntegrationSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IntegrationSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all configured integrations of a given kind.
     * @param integrationKey The key used to specify the integration kind.
     * @param {*} [options] Override http request options.
     */
    public getIntegrationSubscriptions (integrationKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Integration;  }> {
        const localVarPath = this.basePath + '/integrations/{integrationKey}'
            .replace('{' + 'integrationKey' + '}', encodeURIComponent(String(integrationKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationKey' is not null or undefined
        if (integrationKey === null || integrationKey === undefined) {
            throw new Error('Required parameter integrationKey was null or undefined when calling getIntegrationSubscriptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Integration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Integration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all configured audit log event integrations associated with this account.
     * @param {*} [options] Override http request options.
     */
    public getIntegrations (options: any = {}) : Promise<{ response: http.ClientResponse; body: Integrations;  }> {
        const localVarPath = this.basePath + '/integrations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Integrations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Integrations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify an integration subscription by ID.
     * @param integrationKey The key used to specify the integration kind.
     * @param integrationId The integration ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchIntegrationSubscription (integrationKey: string, integrationId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }> {
        const localVarPath = this.basePath + '/integrations/{integrationKey}/{integrationId}'
            .replace('{' + 'integrationKey' + '}', encodeURIComponent(String(integrationKey)))
            .replace('{' + 'integrationId' + '}', encodeURIComponent(String(integrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationKey' is not null or undefined
        if (integrationKey === null || integrationKey === undefined) {
            throw new Error('Required parameter integrationKey was null or undefined when calling patchIntegrationSubscription.');
        }

        // verify required parameter 'integrationId' is not null or undefined
        if (integrationId === null || integrationId === undefined) {
            throw new Error('Required parameter integrationId was null or undefined when calling patchIntegrationSubscription.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchIntegrationSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IntegrationSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new integration subscription of a given kind.
     * @param integrationKey The key used to specify the integration kind.
     * @param subscriptionBody Create a new integration subscription.
     * @param {*} [options] Override http request options.
     */
    public postIntegrationSubscription (integrationKey: string, subscriptionBody: SubscriptionBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }> {
        const localVarPath = this.basePath + '/integrations/{integrationKey}'
            .replace('{' + 'integrationKey' + '}', encodeURIComponent(String(integrationKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationKey' is not null or undefined
        if (integrationKey === null || integrationKey === undefined) {
            throw new Error('Required parameter integrationKey was null or undefined when calling postIntegrationSubscription.');
        }

        // verify required parameter 'subscriptionBody' is not null or undefined
        if (subscriptionBody === null || subscriptionBody === undefined) {
            throw new Error('Required parameter subscriptionBody was null or undefined when calling postIntegrationSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscriptionBody, "SubscriptionBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IntegrationSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IntegrationSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectsApiApiKeys {
    Token,
}

export class ProjectsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectsApiApiKeys, value: string) {
        (this.authentications as any)[ProjectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public deleteProject (projectKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single project by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request options.
     */
    public getProject (projectKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all projects in the account.
     * @param {*} [options] Override http request options.
     */
    public getProjects (options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a project by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchProject (projectKey: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchProject.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new project with the given key and name.
     * @param projectBody Project keys must be unique within an account.
     * @param {*} [options] Override http request options.
     */
    public postProject (projectBody: ProjectBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectBody' is not null or undefined
        if (projectBody === null || projectBody === undefined) {
            throw new Error('Required parameter projectBody was null or undefined when calling postProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(projectBody, "ProjectBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RelayProxyConfigurationsApiApiKeys {
    Token,
}

export class RelayProxyConfigurationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RelayProxyConfigurationsApiApiKeys, value: string) {
        (this.authentications as any)[RelayProxyConfigurationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a relay proxy configuration by ID.
     * @param id The relay proxy configuration ID
     * @param {*} [options] Override http request options.
     */
    public deleteRelayProxyConfig (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRelayProxyConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single relay proxy configuration by ID.
     * @param id The relay proxy configuration ID
     * @param {*} [options] Override http request options.
     */
    public getRelayProxyConfig (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRelayProxyConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RelayProxyConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of relay proxy configurations in the account.
     * @param {*} [options] Override http request options.
     */
    public getRelayProxyConfigs (options: any = {}) : Promise<{ response: http.ClientResponse; body: RelayProxyConfigs;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RelayProxyConfigs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RelayProxyConfigs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a relay proxy configuration by ID.
     * @param id The relay proxy configuration ID
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchRelayProxyConfig (id: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling patchRelayProxyConfig.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchRelayProxyConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RelayProxyConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new relay proxy config.
     * @param relayProxyConfigBody Create a new relay proxy configuration
     * @param {*} [options] Override http request options.
     */
    public postRelayAutoConfig (relayProxyConfigBody: RelayProxyConfigBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'relayProxyConfigBody' is not null or undefined
        if (relayProxyConfigBody === null || relayProxyConfigBody === undefined) {
            throw new Error('Required parameter relayProxyConfigBody was null or undefined when calling postRelayAutoConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(relayProxyConfigBody, "RelayProxyConfigBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RelayProxyConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset a relay proxy configuration's secret key with an optional expiry time for the old key.
     * @param id The relay proxy configuration ID
     * @param expiry An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately
     * @param {*} [options] Override http request options.
     */
    public resetRelayProxyConfig (id: string, expiry?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }> {
        const localVarPath = this.basePath + '/account/relay-auto-configs/{id}/reset'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling resetRelayProxyConfig.');
        }

        if (expiry !== undefined) {
            localVarQueryParameters['expiry'] = ObjectSerializer.serialize(expiry, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RelayProxyConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RelayProxyConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RootApiApiKeys {
    Token,
}

export class RootApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RootApiApiKeys, value: string) {
        (this.authentications as any)[RootApiApiKeys[key]].apiKey = value;
    }
    /**
     * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
     * @param {*} [options] Override http request options.
     */
    public getRoot (options: any = {}) : Promise<{ response: http.ClientResponse; body: Links;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Links;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Links");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamMembersApiApiKeys {
    Token,
}

export class TeamMembersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamMembersApiApiKeys, value: string) {
        (this.authentications as any)[TeamMembersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a team member by ID.
     * @param memberId The member ID.
     * @param {*} [options] Override http request options.
     */
    public deleteMember (memberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the current team member associated with the token
     * @param {*} [options] Override http request options.
     */
    public getMe (options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single team member by ID.
     * @param memberId The member ID.
     * @param {*} [options] Override http request options.
     */
    public getMember (memberId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling getMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of all members in the account.
     * @param limit The number of objects to return. Defaults to -1, which returns everything.
     * @param offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param filter A comma-separated list of filters. Each filter is of the form field:value.
     * @param sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public getMembers (limit?: number, offset?: number, filter?: string, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Members;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Members;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Members");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a team member by ID.
     * @param memberId The member ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchMember (memberId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Member;  }> {
        const localVarPath = this.basePath + '/members/{memberId}'
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling patchMember.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Member;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Member");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Invite new members.
     * @param membersBody New members to invite.
     * @param {*} [options] Override http request options.
     */
    public postMembers (membersBody: Array<MembersBody>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Members;  }> {
        const localVarPath = this.basePath + '/members';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'membersBody' is not null or undefined
        if (membersBody === null || membersBody === undefined) {
            throw new Error('Required parameter membersBody was null or undefined when calling postMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(membersBody, "Array<MembersBody>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Members;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Members");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSegmentsApiApiKeys {
    Token,
}

export class UserSegmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSegmentsApiApiKeys, value: string) {
        (this.authentications as any)[UserSegmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request options.
     */
    public deleteUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling deleteUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get expiring user targets for user segment
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request options.
     */
    public getExpiringUserTargetsOnSegment (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationForSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single user segment by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request options.
     */
    public getUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling getUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all user segments in the given project.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param tag Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request options.
     */
    public getUserSegments (projectKey: string, environmentKey: string, tag?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegments;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserSegments.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserSegments.');
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update, add, or delete expiring user targets on user segment
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchExpiringUserTargetsOnSegment (projectKey: string, environmentKey: string, userSegmentKey: string, semanticPatchWithComment: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
        }

        // verify required parameter 'semanticPatchWithComment' is not null or undefined
        if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
            throw new Error('Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargetsOnSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(semanticPatchWithComment, "any")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationForSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationForSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a partial update to a user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param patchOnly Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchUserSegment (projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling patchUserSegment.');
        }

        // verify required parameter 'patchOnly' is not null or undefined
        if (patchOnly === null || patchOnly === undefined) {
            throw new Error('Required parameter patchOnly was null or undefined when calling patchUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchOnly, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new user segment.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentBody Create a new user segment.
     * @param {*} [options] Override http request options.
     */
    public postUserSegment (projectKey: string, environmentKey: string, userSegmentBody: UserSegmentBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserSegment;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling postUserSegment.');
        }

        // verify required parameter 'userSegmentBody' is not null or undefined
        if (userSegmentBody === null || userSegmentBody === undefined) {
            throw new Error('Required parameter userSegmentBody was null or undefined when calling postUserSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSegmentBody, "UserSegmentBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update targets included or excluded in an unbounded segment
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userSegmentKey The user segment&#39;s key. The key identifies the user segment in your code.
     * @param unboundedSegmentTargetsBody Add or remove user targets to the included or excluded lists on an unbounded segment
     * @param {*} [options] Override http request options.
     */
    public updatedUnboundedSegmentTargets (projectKey: string, environmentKey: string, userSegmentKey: string, unboundedSegmentTargetsBody: UnboundedSegmentTargetsBody, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/segments/{projectKey}/{environmentKey}/{userSegmentKey}/unbounded-users'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userSegmentKey' + '}', encodeURIComponent(String(userSegmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling updatedUnboundedSegmentTargets.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling updatedUnboundedSegmentTargets.');
        }

        // verify required parameter 'userSegmentKey' is not null or undefined
        if (userSegmentKey === null || userSegmentKey === undefined) {
            throw new Error('Required parameter userSegmentKey was null or undefined when calling updatedUnboundedSegmentTargets.');
        }

        // verify required parameter 'unboundedSegmentTargetsBody' is not null or undefined
        if (unboundedSegmentTargetsBody === null || unboundedSegmentTargetsBody === undefined) {
            throw new Error('Required parameter unboundedSegmentTargetsBody was null or undefined when calling updatedUnboundedSegmentTargets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(unboundedSegmentTargetsBody, "UnboundedSegmentTargetsBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserSettingsApiApiKeys {
    Token,
}

export class UserSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserSettingsApiApiKeys, value: string) {
        (this.authentications as any)[UserSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get expiring dates on flags for user
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public getExpiringUserTargetsForUser (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationOnFlagsForUser;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getExpiringUserTargetsForUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getExpiringUserTargetsForUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getExpiringUserTargetsForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationOnFlagsForUser;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationOnFlagsForUser");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request options.
     */
    public getUserFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling getUserFlagSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSetting;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSetting");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public getUserFlagSettings (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUserFlagSettings.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUserFlagSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFlagSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFlagSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update, add, or delete expiring user targets for a single user on all flags
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request options.
     */
    public patchExpiringUserTargetsForFlags (projectKey: string, environmentKey: string, userKey: string, semanticPatchWithComment: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserTargetingExpirationOnFlagsForUser;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
        }

        // verify required parameter 'semanticPatchWithComment' is not null or undefined
        if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
            throw new Error('Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargetsForFlags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(semanticPatchWithComment, "any")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserTargetingExpirationOnFlagsForUser;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTargetingExpirationOnFlagsForUser");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Specifically enable or disable a feature flag for a user based on their key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param featureFlagKey The feature flag&#39;s key. The key identifies the flag in your code.
     * @param userSettingsBody 
     * @param {*} [options] Override http request options.
     */
    public putFlagSetting (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: UserSettingsBody, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)))
            .replace('{' + 'featureFlagKey' + '}', encodeURIComponent(String(featureFlagKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'featureFlagKey' is not null or undefined
        if (featureFlagKey === null || featureFlagKey === undefined) {
            throw new Error('Required parameter featureFlagKey was null or undefined when calling putFlagSetting.');
        }

        // verify required parameter 'userSettingsBody' is not null or undefined
        if (userSettingsBody === null || userSettingsBody === undefined) {
            throw new Error('Required parameter userSettingsBody was null or undefined when calling putFlagSetting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userSettingsBody, "UserSettingsBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    Token,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user by ID.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public deleteUser (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling deleteUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param q Search query.
     * @param limit Pagination limit.
     * @param offset Specifies the first item to return in the collection.
     * @param after A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
     * @param {*} [options] Override http request options.
     */
    public getSearchUsers (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/user-search/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getSearchUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getSearchUsers.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user by key.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param userKey The user&#39;s key.
     * @param {*} [options] Override http request options.
     */
    public getUser (projectKey: string, environmentKey: string, userKey: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}/{userKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)))
            .replace('{' + 'userKey' + '}', encodeURIComponent(String(userKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUser.');
        }

        // verify required parameter 'userKey' is not null or undefined
        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling getUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to 'limit' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
     * @param projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param limit Pagination limit.
     * @param h This parameter is required when following \&quot;next\&quot; links.
     * @param scrollId This parameter is required when following \&quot;next\&quot; links.
     * @param {*} [options] Override http request options.
     */
    public getUsers (projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/users/{projectKey}/{environmentKey}'
            .replace('{' + 'projectKey' + '}', encodeURIComponent(String(projectKey)))
            .replace('{' + 'environmentKey' + '}', encodeURIComponent(String(environmentKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectKey' is not null or undefined
        if (projectKey === null || projectKey === undefined) {
            throw new Error('Required parameter projectKey was null or undefined when calling getUsers.');
        }

        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling getUsers.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (h !== undefined) {
            localVarQueryParameters['h'] = ObjectSerializer.serialize(h, "string");
        }

        if (scrollId !== undefined) {
            localVarQueryParameters['scrollId'] = ObjectSerializer.serialize(scrollId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
    Token,
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Token': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a webhook by ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public deleteWebhook (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling deleteWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a webhook by ID.
     * @param resourceId The resource ID.
     * @param {*} [options] Override http request options.
     */
    public getWebhook (resourceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of all webhooks.
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhooks;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhooks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhooks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Modify a webhook by ID.
     * @param resourceId The resource ID.
     * @param patchDelta Requires a JSON Patch representation of the desired changes to the project. &#39;http://jsonpatch.com/&#39;
     * @param {*} [options] Override http request options.
     */
    public patchWebhook (resourceId: string, patchDelta: Array<PatchOperation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{resourceId}'
            .replace('{' + 'resourceId' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling patchWebhook.');
        }

        // verify required parameter 'patchDelta' is not null or undefined
        if (patchDelta === null || patchDelta === undefined) {
            throw new Error('Required parameter patchDelta was null or undefined when calling patchWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchDelta, "Array<PatchOperation>")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a webhook.
     * @param webhookBody New webhook.
     * @param {*} [options] Override http request options.
     */
    public postWebhook (webhookBody: WebhookBody, options: any = {}) : Promise<{ response: http.ClientResponse; body: Webhook;  }> {
        const localVarPath = this.basePath + '/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookBody' is not null or undefined
        if (webhookBody === null || webhookBody === undefined) {
            throw new Error('Required parameter webhookBody was null or undefined when calling postWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhookBody, "WebhookBody")
        };

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Webhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Webhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
